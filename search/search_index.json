{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wildcard Match \ue157 Overview \ue157 Wildcard Match provides an enhanced fnmatch , glob and pathlib library in order to provide file matching and globbing that more closely follows the features found in Bash. In some ways these libraries are similar to Python's builtin libraries as they provide a similar interface to match, filter, and glob the file system. But they also include a number of features found in Bash's globbing such as backslash escaping, brace expansion, extended glob pattern groups, etc. They also add a number of new useful functions as well, such as globmatch which functions like fnmatch , but for paths. Paths that would normally be returned when providing glob a pattern should also be properly match in globmatch . Wildcard Match uses Bash as a guide when making decisions on behavior in fnmatch and glob . Behavior may differ from Bash version to Bash version, but an attempt is made to keep Wildcard Match up with the latest relevant changes. With all of this said, there may be a few corner cases in which we've intentionally chosen to not exactly mirror Bash. If an issue is found where Wildcard Match seems to deviate in an illogical way, we'd love to hear about it in the issue tracker . If all you are looking for is an alternative fnmatch and/or glob library that follows much more closely to Bash, or even a pathlib library that taps into a more advanced glob library, Wildcard Match has you covered, but Wildcard Match also adds a file search utility called wcmatch that is built on top of fnmatch and globmatch . It was originally written for Rummage , but split out into this project to be used by other projects that may find its approach useful. Features \ue157 A quick overview of Wildcard Match's Features: Provides an interface comparable to Python's builtin in fnamtch and glob . Allows for a much more configurable experience when matching or globbing with many more features. Adds support for ** in glob. Adds support for escaping characters with \\ . Add support for POSIX style character classes inside sequences: [[:alnum:]] , etc. The C locale is used for byte strings and Unicode properties for Unicode strings. Adds support for brace expansion: a{b,{c,d}} \u2192 ab ac ad . Adds support for extended match patterns: @(...) , +(...) , *(...) , ?(...) , and !(...) . Adds ability to match path names via the path centric globmatch . Provides a pathlib variant that uses Wildcard Match's glob library instead of Python's default. Provides an alternative file crawler called wcmatch . And more\u2026 Installation \ue157 Installation is easy with pip: pip install wcmatch Libraries \ue157 fnmatch : A file name matching library. glob : A file system searching and file path matching library. pathlib : A implementation of Python's pathlib that uses our own glob implementation. wcmatch : An alternative file search library built on fnmatch and globmatch .","title":"Wildcard Match"},{"location":"#wildcard-match","text":"","title":"Wildcard Match"},{"location":"#overview","text":"Wildcard Match provides an enhanced fnmatch , glob and pathlib library in order to provide file matching and globbing that more closely follows the features found in Bash. In some ways these libraries are similar to Python's builtin libraries as they provide a similar interface to match, filter, and glob the file system. But they also include a number of features found in Bash's globbing such as backslash escaping, brace expansion, extended glob pattern groups, etc. They also add a number of new useful functions as well, such as globmatch which functions like fnmatch , but for paths. Paths that would normally be returned when providing glob a pattern should also be properly match in globmatch . Wildcard Match uses Bash as a guide when making decisions on behavior in fnmatch and glob . Behavior may differ from Bash version to Bash version, but an attempt is made to keep Wildcard Match up with the latest relevant changes. With all of this said, there may be a few corner cases in which we've intentionally chosen to not exactly mirror Bash. If an issue is found where Wildcard Match seems to deviate in an illogical way, we'd love to hear about it in the issue tracker . If all you are looking for is an alternative fnmatch and/or glob library that follows much more closely to Bash, or even a pathlib library that taps into a more advanced glob library, Wildcard Match has you covered, but Wildcard Match also adds a file search utility called wcmatch that is built on top of fnmatch and globmatch . It was originally written for Rummage , but split out into this project to be used by other projects that may find its approach useful.","title":"Overview"},{"location":"#features","text":"A quick overview of Wildcard Match's Features: Provides an interface comparable to Python's builtin in fnamtch and glob . Allows for a much more configurable experience when matching or globbing with many more features. Adds support for ** in glob. Adds support for escaping characters with \\ . Add support for POSIX style character classes inside sequences: [[:alnum:]] , etc. The C locale is used for byte strings and Unicode properties for Unicode strings. Adds support for brace expansion: a{b,{c,d}} \u2192 ab ac ad . Adds support for extended match patterns: @(...) , +(...) , *(...) , ?(...) , and !(...) . Adds ability to match path names via the path centric globmatch . Provides a pathlib variant that uses Wildcard Match's glob library instead of Python's default. Provides an alternative file crawler called wcmatch . And more\u2026","title":"Features"},{"location":"#installation","text":"Installation is easy with pip: pip install wcmatch","title":"Installation"},{"location":"#libraries","text":"fnmatch : A file name matching library. glob : A file system searching and file path matching library. pathlib : A implementation of Python's pathlib that uses our own glob implementation. wcmatch : An alternative file search library built on fnmatch and globmatch .","title":"Libraries"},{"location":"changelog/","text":"Changelog \ue157 5.0.0 \ue157 NEW : Add wcmatch.pathlib which contains pathlib variants that uses wcmatch.glob instead of the default Python glob. NEW : escape and raw_escape can manually be forced to use Windows or Linux/Unix logic via the keyword only argument by setting to False or True respectively. The default is None which will auto detect the system. NEW : The deprecated flag FORCECASE has now been removed. NEW : The deprecated functions globsplit and fnsplit have been removed. NEW : The deprecated variables version and version_info have been removed. 4.3.1 \ue157 FIX : Regression for root level literal matches in glob . FIX : Bug where glob would mistakenly abort if a pattern started with a literal file or directory and could not match a file or directory. This caused subsequent patterns in the chain to not get evaluated. 4.3.0 \ue157 NEW : Add CASE flag which allows for case sensitive paths on Linux, macOS, and Windows. Windows drive letters and UNC //host-name/share-name/ portion are still treated insensitively, but all directories will be treated with case sensitivity. NEW : With the recent addition of CASE and FORCEUNIX , FORCECASE is no longer needed. Deprecate FORCECASE which will be removed at some future point. 4.2.0 \ue157 NEW : Drop Python 3.4 support. NEW : Add flags FORCEWIN and FORCEUNIX to force Windows or Linux/Unix path logic on commands that do not access the file system: translate , fnmatch , filter , globmatch , globfilter , etc. These flags will not work with glob , iglob or with the WcMatch class. It also will not work when using the REALPATH flag with things like fnmatch , filter , globmatch , globfilter . FIX : glob corner case where the first folder, if defined as a literal name (not a magic pattern), would not be treated properly if IGNORECASE was enabled in Linux. 4.1.0 \ue157 NEW : Add WcMatch.is_aborted . FIX : Remove deprecation of kill and reset in WcMatch . There are legitimate reasons to not deprecate killing via kill instead of simply breaking. FIX : If for any reason, a file exists, but fails \"is directory\" check, consider it as a file. 4.0.1 \ue157 FIX : Fix regression with exclusion patterns that use braces in glob . FIX : Translate functions should have NODIR patterns exclude if matched not exclude if not matched. 4.0.0 \ue157 NEW : Deprecated WcMatch class methods kill and reset . WcMatch should be broken with a simple break statement instead. NEW : Add a new flag MARK to force glob to return directories with a trailing slash. NEW : Add MATCHBASE that causes glob glob related functions and WcMatch , when the pattern has no slashes in it, to seek for any file anywhere in the tree with a matching basename. NEW : Add NODIR that causes glob matchers and crawlers to only match and return files. NEW : Exclusion patterns (enabled with NEGATE ) now always enable DOTALL in the exclusion patterns. They also will match symlinks in ** patterns. Only non NEGATE patterns that are paired with a NEGATE pattern are subject to symlinks and dot rules. Exclusion patterns themselves allow dots and symlinks to make filtering easier. NEW : Exclusion patterns no longer provide a default inclusion pattern if one is not specified. Exclusion patterns are meant to filter the results of inclusion patterns. You can either use the SPLIT flag and provide an inclusion pattern with your default ('default_pattern|!exclusion'), or feed in a list of multiple patterns instead of a single string ( ['inclusion', '!exclusion'] ). If you really need the old behavior, you can use the NEGATEALL flag which will provide a default inclusion pattern that matches all files. NEW : Translate now outputs exclusion patterns so that if they match, the file is excluded. This is opposite logic to how it used to be, but is more efficient. FIX : An empty pattern in glob should not match slashes. 3.0.2 \ue157 FIX : Fix an offset issue when processing an absolute path pattern in glob on Linux or macOS. FIX : Fix an issue where the glob command would use GLOBSTAR logic on ** even when GLOBSTAR was disabled. 3.0.1 \ue157 FIX : In the WcMatch class, defer hidden file check until after the file or directory is compared against patterns to potentially avoid calling hidden if the pattern doesn't match. The reduced lstat calls improve performance. 3.0.0 \ue157 NEW : globsplit and fnsplit have been deprecated. Users are encouraged to use the new SPLIT flag to allow functions to use multiple wildcard paths delimited by | . NEW : globmatch and globfilter will now parse provided paths as real paths if the new REALPATH flag is set. This has the advantage of allowing the commands to be aware of symlinks and properly apply related logic (whether to follow the links or not). It also helps to clarify ambiguous cases where it isn't clear if a file path references a directory because the trailing slash was omitted. It also allows the command to be aware of Windows drives evaluate the path in proper context compared to the current working directory. NEW : WcMatch class no longer accepts the recursive or show_hidden parameter, instead the RECURSIVE or HIDDEN flag must be used. NEW : WcMatch class now can search symlink directories with the new SYMLINK flag. NEW : glob and iglob functions now behave like Bash 5.0 in regards to symlinks in GLOBSTAR ( ** ). GLOBSTAR will ignore symlink directories. This affects other functions such as globmatch and globfilter when the REALPATH flag is enabled. NEW : New flag called FOLLOW was added to force related glob commands to recognize and follow symlink directories. FIX : Fix glob regression where inverse patterns such as !**/test/** would allow a directory base/test to match when it should have excluded it. FIX : glob should handle root paths ( / ) properly, and on Windows, it should assume the drive of the current working directory. 2.2.1 \ue157 FIX : EXTMATCH / EXTGLOB should allow literal dots and should not treat dots like sequences do. FIX : Fix !(...) extended match patterns in glob and globmatch so that they properly match . and .. if their pattern starts with . . FIX : Fix !(...) extended match patterns so that they handle path separators correctly. FIX : Patterns such as ? or [.] should not trigger matching directories . and .. in glob and globmatch . 2.2.0 \ue157 NEW : Officially support Python 3.8. 2.1.0 \ue157 NEW : Deprecate version and version_info in favor of the more standard __version__ and __version_info__ . FIX : Fix issue where exclusion patterns would trigger before end of path. FIX : Fix GLOBSTAR regular expression pattern issues. 2.0.3 \ue157 FIX : In glob , properly handle files in the current working directory when give a literal pattern that matches it. 2.0.2 \ue157 FIX : wcmatch override events ( on_error and on_skip ) should verify the return is not None and not not falsy . 2.0.1 \ue157 FIX : Can't install due to requirements being assigned to setup opposed to install. 2.0.0 \ue157 Breaking Changes Version 2.0.0 introduces breaking changes in regards to flags. This is meant to bring about consistency amongst the provided libraries. Flag names have been changed in some cases, and logic has been inverted in some cases. NEW : Glob's NOBRACE , NOGLOBSTAR , and NOEXTGLOB flags are now BRACE , GLOBSTAR , and EXTGLOB and now enable the features instead of disabling the features. This logic matches the provided fnmatch and wcmatch . NEW : Glob's DOTGLOB and EXTGLOB also have the respective aliases DOTMATCH and EXTMATCH to provide consistent flags across provided libraries, but the GLOB variants that match Bash's feature names can still be used. NEW : fnmatch 's PERIOD flag has been replaced with DOTMATCH with inverted logic from what was originally provided. NEW : Documentation exposes the shorthand form of flags: FORCECASE \u2192 F , etc. FIX : Wcmatch always documented that it had the flag named EXTMATCH , but internally it was actually EXTGLOB , this was a bug though. EXTMATCH is now the documented and the actual flag to use. 1.0.2 \ue157 FIX : Officially support Python 3.7. 1.0.1 \ue157 FIX : Ensure that all patterns in glob that have a directory preceding ** but also end with ** returns the preceding directory. FIX : Fix byte conversion in path normalization. FIX : Ensure POSIX character classes, when at the start of a sequence, properly have hyphens escaped following it. [[:ascii:]-z] should convert to [\\x00-\\x7f\\\\-b] not [\\x00-\\x7f-b] . FIX : Fix an issue where we would fail because we couldn't covert raw characters even though raw character parsing was disabled. FIX : Better default for file patterns. Before if no pattern was provided for files, '*' was assumed, now it is '' , and if '' is used, all files will be matched. This works better for when full path is enabled as you get the same file matching logic. 1.0.0 \ue157 Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#500","text":"NEW : Add wcmatch.pathlib which contains pathlib variants that uses wcmatch.glob instead of the default Python glob. NEW : escape and raw_escape can manually be forced to use Windows or Linux/Unix logic via the keyword only argument by setting to False or True respectively. The default is None which will auto detect the system. NEW : The deprecated flag FORCECASE has now been removed. NEW : The deprecated functions globsplit and fnsplit have been removed. NEW : The deprecated variables version and version_info have been removed.","title":"5.0.0"},{"location":"changelog/#431","text":"FIX : Regression for root level literal matches in glob . FIX : Bug where glob would mistakenly abort if a pattern started with a literal file or directory and could not match a file or directory. This caused subsequent patterns in the chain to not get evaluated.","title":"4.3.1"},{"location":"changelog/#430","text":"NEW : Add CASE flag which allows for case sensitive paths on Linux, macOS, and Windows. Windows drive letters and UNC //host-name/share-name/ portion are still treated insensitively, but all directories will be treated with case sensitivity. NEW : With the recent addition of CASE and FORCEUNIX , FORCECASE is no longer needed. Deprecate FORCECASE which will be removed at some future point.","title":"4.3.0"},{"location":"changelog/#420","text":"NEW : Drop Python 3.4 support. NEW : Add flags FORCEWIN and FORCEUNIX to force Windows or Linux/Unix path logic on commands that do not access the file system: translate , fnmatch , filter , globmatch , globfilter , etc. These flags will not work with glob , iglob or with the WcMatch class. It also will not work when using the REALPATH flag with things like fnmatch , filter , globmatch , globfilter . FIX : glob corner case where the first folder, if defined as a literal name (not a magic pattern), would not be treated properly if IGNORECASE was enabled in Linux.","title":"4.2.0"},{"location":"changelog/#410","text":"NEW : Add WcMatch.is_aborted . FIX : Remove deprecation of kill and reset in WcMatch . There are legitimate reasons to not deprecate killing via kill instead of simply breaking. FIX : If for any reason, a file exists, but fails \"is directory\" check, consider it as a file.","title":"4.1.0"},{"location":"changelog/#401","text":"FIX : Fix regression with exclusion patterns that use braces in glob . FIX : Translate functions should have NODIR patterns exclude if matched not exclude if not matched.","title":"4.0.1"},{"location":"changelog/#400","text":"NEW : Deprecated WcMatch class methods kill and reset . WcMatch should be broken with a simple break statement instead. NEW : Add a new flag MARK to force glob to return directories with a trailing slash. NEW : Add MATCHBASE that causes glob glob related functions and WcMatch , when the pattern has no slashes in it, to seek for any file anywhere in the tree with a matching basename. NEW : Add NODIR that causes glob matchers and crawlers to only match and return files. NEW : Exclusion patterns (enabled with NEGATE ) now always enable DOTALL in the exclusion patterns. They also will match symlinks in ** patterns. Only non NEGATE patterns that are paired with a NEGATE pattern are subject to symlinks and dot rules. Exclusion patterns themselves allow dots and symlinks to make filtering easier. NEW : Exclusion patterns no longer provide a default inclusion pattern if one is not specified. Exclusion patterns are meant to filter the results of inclusion patterns. You can either use the SPLIT flag and provide an inclusion pattern with your default ('default_pattern|!exclusion'), or feed in a list of multiple patterns instead of a single string ( ['inclusion', '!exclusion'] ). If you really need the old behavior, you can use the NEGATEALL flag which will provide a default inclusion pattern that matches all files. NEW : Translate now outputs exclusion patterns so that if they match, the file is excluded. This is opposite logic to how it used to be, but is more efficient. FIX : An empty pattern in glob should not match slashes.","title":"4.0.0"},{"location":"changelog/#302","text":"FIX : Fix an offset issue when processing an absolute path pattern in glob on Linux or macOS. FIX : Fix an issue where the glob command would use GLOBSTAR logic on ** even when GLOBSTAR was disabled.","title":"3.0.2"},{"location":"changelog/#301","text":"FIX : In the WcMatch class, defer hidden file check until after the file or directory is compared against patterns to potentially avoid calling hidden if the pattern doesn't match. The reduced lstat calls improve performance.","title":"3.0.1"},{"location":"changelog/#300","text":"NEW : globsplit and fnsplit have been deprecated. Users are encouraged to use the new SPLIT flag to allow functions to use multiple wildcard paths delimited by | . NEW : globmatch and globfilter will now parse provided paths as real paths if the new REALPATH flag is set. This has the advantage of allowing the commands to be aware of symlinks and properly apply related logic (whether to follow the links or not). It also helps to clarify ambiguous cases where it isn't clear if a file path references a directory because the trailing slash was omitted. It also allows the command to be aware of Windows drives evaluate the path in proper context compared to the current working directory. NEW : WcMatch class no longer accepts the recursive or show_hidden parameter, instead the RECURSIVE or HIDDEN flag must be used. NEW : WcMatch class now can search symlink directories with the new SYMLINK flag. NEW : glob and iglob functions now behave like Bash 5.0 in regards to symlinks in GLOBSTAR ( ** ). GLOBSTAR will ignore symlink directories. This affects other functions such as globmatch and globfilter when the REALPATH flag is enabled. NEW : New flag called FOLLOW was added to force related glob commands to recognize and follow symlink directories. FIX : Fix glob regression where inverse patterns such as !**/test/** would allow a directory base/test to match when it should have excluded it. FIX : glob should handle root paths ( / ) properly, and on Windows, it should assume the drive of the current working directory.","title":"3.0.0"},{"location":"changelog/#221","text":"FIX : EXTMATCH / EXTGLOB should allow literal dots and should not treat dots like sequences do. FIX : Fix !(...) extended match patterns in glob and globmatch so that they properly match . and .. if their pattern starts with . . FIX : Fix !(...) extended match patterns so that they handle path separators correctly. FIX : Patterns such as ? or [.] should not trigger matching directories . and .. in glob and globmatch .","title":"2.2.1"},{"location":"changelog/#220","text":"NEW : Officially support Python 3.8.","title":"2.2.0"},{"location":"changelog/#210","text":"NEW : Deprecate version and version_info in favor of the more standard __version__ and __version_info__ . FIX : Fix issue where exclusion patterns would trigger before end of path. FIX : Fix GLOBSTAR regular expression pattern issues.","title":"2.1.0"},{"location":"changelog/#203","text":"FIX : In glob , properly handle files in the current working directory when give a literal pattern that matches it.","title":"2.0.3"},{"location":"changelog/#202","text":"FIX : wcmatch override events ( on_error and on_skip ) should verify the return is not None and not not falsy .","title":"2.0.2"},{"location":"changelog/#201","text":"FIX : Can't install due to requirements being assigned to setup opposed to install.","title":"2.0.1"},{"location":"changelog/#200","text":"Breaking Changes Version 2.0.0 introduces breaking changes in regards to flags. This is meant to bring about consistency amongst the provided libraries. Flag names have been changed in some cases, and logic has been inverted in some cases. NEW : Glob's NOBRACE , NOGLOBSTAR , and NOEXTGLOB flags are now BRACE , GLOBSTAR , and EXTGLOB and now enable the features instead of disabling the features. This logic matches the provided fnmatch and wcmatch . NEW : Glob's DOTGLOB and EXTGLOB also have the respective aliases DOTMATCH and EXTMATCH to provide consistent flags across provided libraries, but the GLOB variants that match Bash's feature names can still be used. NEW : fnmatch 's PERIOD flag has been replaced with DOTMATCH with inverted logic from what was originally provided. NEW : Documentation exposes the shorthand form of flags: FORCECASE \u2192 F , etc. FIX : Wcmatch always documented that it had the flag named EXTMATCH , but internally it was actually EXTGLOB , this was a bug though. EXTMATCH is now the documented and the actual flag to use.","title":"2.0.0"},{"location":"changelog/#102","text":"FIX : Officially support Python 3.7.","title":"1.0.2"},{"location":"changelog/#101","text":"FIX : Ensure that all patterns in glob that have a directory preceding ** but also end with ** returns the preceding directory. FIX : Fix byte conversion in path normalization. FIX : Ensure POSIX character classes, when at the start of a sequence, properly have hyphens escaped following it. [[:ascii:]-z] should convert to [\\x00-\\x7f\\\\-b] not [\\x00-\\x7f-b] . FIX : Fix an issue where we would fail because we couldn't covert raw characters even though raw character parsing was disabled. FIX : Better default for file patterns. Before if no pattern was provided for files, '*' was assumed, now it is '' , and if '' is used, all files will be matched. This works better for when full path is enabled as you get the same file matching logic.","title":"1.0.1"},{"location":"changelog/#100","text":"Initial release","title":"1.0.0"},{"location":"fnmatch/","text":"wcmatch.fnmatch \ue157 from wcmatch import fnmatch Syntax \ue157 The fnmatch library is similar to the builtin fnmatch , but with some enhancements and some differences. It is mainly used for matching filenames with glob patterns. For path names, Wildcard Match's globmatch is a more appropriate choice. Not all of the features listed below are enabled by default. See flags for more information. Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything. ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. [[:alnum:]] POSIX style character classes inside sequences. The C locale is used for byte strings and Unicode properties for Unicode strings. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character, it will be treated as a normal character. ! Exclusion pattern (with configuration, can use - instead of ! ). ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . {} Bash style brace expansions. This is applied to patterns before anything else. Slashes are generally treated as normal characters, but on windows they will be normalized: / will become \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, it will be handled. This applies to matching patterns and the filenames the patterns are applied to. If case sensitivity is applied on a Windows system, slashes will not be normalized and pattern and filenames will be treated as a Linux/Unix filename. By default, . is not matched by * , ? , and [] . See the DOTMATCH flag to match . at the start of a filename without a literal . . POSIX Character Classes \ue157 A number of POSIX style character classes are available in the form [:posix:] . They must be used inside sequences: [[:posix:]] . For byte strings, the C locale is used, and the values will for each character class are found in the table below under ASCII . When used in a Unicode string, Unicode properties will be used. [:posix:] \\p{posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9] API \ue157 fnmatch.fnmatch \ue157 def fnmatch ( filename , patterns , * , flags = 0 ) fnmatch takes a file name, a pattern (or list of patterns), and flags. It will return a boolean indicating whether the file name was matched by the pattern(s). >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , r '@(*.txt|*.py)' , flags = fnmatch . EXTMATCH ) True When applying multiple patterns, a file matches if it matches any of the patterns: >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , [ r '*.txt' , r '*.py' ], flags = fnmatch . EXTMATCH ) True Exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with inclusion patterns, a file will be considered matched if one of the inclusion patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , r '*|!*.py' , flags = fnmatch . NEGATE | fnamtch . SPLIT ) False >>> fnmatch . fnmatch ( 'test.txt' , r '*|!*.py' , flags = fnmatch . NEGATE | fnamtch . SPLIT ) True >>> fnmatch . fnmatch ( 'test.txt' , [ r '*.txt' , r '!avoid.txt' ], flags = fnmatch . NEGATE ) True >>> fnmatch . fnmatch ( 'avoid.txt' , [ r '*.txt' , r '!avoid.txt' ], flags = fnmatch . NEGATE ) False As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the NEGATEALL flag. Essentially, it means if you use a pattern such as !*.md , it will assume two pattern were given: * and !*.md . >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , r '!*.py' , flags = fnmatch . NEGATE | fnamtch . NEGATEALL ) False >>> fnmatch . fnmatch ( 'test.txt' , r '!*.py' , flags = fnmatch . NEGATE | fnamtch . NEGATEALL ) True fnmatch.filter \ue157 def filter ( filenames , patterns , * , flags = 0 ): filter takes a list of filenames, a pattern (or list of patterns), and flags. It returns a list of all files that matched the pattern(s). The same logic used for fnmatch is used for filter , albeit more efficient for processing multiple files. >>> from wcmatch import fnmatch >>> fnmatch . filter ([ 'a.txt' , 'b.txt' , 'c.py' ], r '*.txt' ) ['a.txt', 'b.txt'] fnmatch.translate \ue157 def translate ( patterns , * , flags = 0 ): translate takes a file pattern (or list of patterns) and returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns. >>> from wcmatch import translate >>> fnmatch . translate ( r '*.{a,{b,c}}' , flags = fnmatch . BRACE ) (['^(?s:(?=.).*?\\\\.a)$', '^(?s:(?=.).*?\\\\.b)$', '^(?s:(?=.).*?\\\\.c)$'], []) >>> fnmatch . translate ( r '**|!*.{a,{b,c}}' , flags = fnmatch . BRACE | fnmatch . NEGATE | fnmatch . SPLIT ) (['^(?s:(?=.)(?![.]).*?)$'], ['^(?s:(?=.).*?\\\\.a)$', '^(?s:(?=.).*?\\\\.b)$', '^(?s:(?=.).*?\\\\.c)$']) Changed 4.0 Translate now outputs exclusion patterns so that if they match, the file is excluded. This is opposite logic to how it used to be, but is more efficient. Flags \ue157 fnmatch.CASE, fnmatch.C \ue157 CASE forces case sensitivity. CASE has higher priority than IGNORECASE . New 4.3.0 CASE is new in 4.3.0. fnmatch.IGNORECASE, fnmatch.I \ue157 IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE . fnmatch.RAWCHARS, fnmatch.R \ue157 RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' . fnmatch.NEGATE, fnmatch.N \ue157 NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would match any file but Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. If used with the extended match feature, patterns like !(inverse|pattern) will be mistakenly parsed as an exclusion pattern instead of as an inverse extended glob group. See MINUSNEGATE for an alternative syntax that plays nice with extended glob. Changes 4.0 In 4.0, NEGATE now requires a non-exclusion pattern to be paired with it or it will match nothing. If you really need something similar to the old behavior, that would assume a default inclusion pattern, you can use the NEGATEALL . fnmatch.NEGATEALL, fnmatch.A \ue157 NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: * and !*.md , where !*.md is applied to the results of * . Dot files will not be returned unless DOTMATCH . fnmatch.MINUSNEGATE, fnmatch.M \ue157 When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the EXTMATCH option. fnmatch.DOTMATCH, fnmatch.D \ue157 By default, fnmatch and related functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTMATCH allows the meta characters (such as * ) to match dots like any other character. Dots will not be matched in [] , * , or ? . fnmatch.EXTMATCH, fnmatch.E \ue157 EXTMATCH enables extended pattern matching. This includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. fnmatch.BRACE, fnmatch.B \ue157 BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns. fnmatch.SPLIT, fnmatch.S \ue157 SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the delimiters if needed: \\| . >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> fnmatch . fnmatch ( 'test.py' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True fnmatch.FORCEWIN, fnmatch.W \ue157 FORCEWIN will force Windows name and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized. This is great if you need to match Windows specific names on a Linux/Unix system. If FORCEWIN is used along side FORCEUNIX , both will be ignored. New 4.2.0 FORCEWIN is new in 4.2.0. fnmatch.FORCEUNIX, fnmatch.U \ue157 FORCEUNIX will force Linux/Unix name and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific names on a Windows system. When using FORCEUNIX , the names are assumed to be case sensitive, but you can use IGNORECASE to use case insensitivity. If FORCEUNIX is used along side FORCEWIN , both will be ignored. New 4.2.0 FORCEUNIX is new in 4.2.0.","title":"Fnmatch"},{"location":"fnmatch/#wcmatchfnmatch","text":"from wcmatch import fnmatch","title":"wcmatch.fnmatch"},{"location":"fnmatch/#syntax","text":"The fnmatch library is similar to the builtin fnmatch , but with some enhancements and some differences. It is mainly used for matching filenames with glob patterns. For path names, Wildcard Match's globmatch is a more appropriate choice. Not all of the features listed below are enabled by default. See flags for more information. Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything. ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. [[:alnum:]] POSIX style character classes inside sequences. The C locale is used for byte strings and Unicode properties for Unicode strings. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character, it will be treated as a normal character. ! Exclusion pattern (with configuration, can use - instead of ! ). ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . {} Bash style brace expansions. This is applied to patterns before anything else. Slashes are generally treated as normal characters, but on windows they will be normalized: / will become \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, it will be handled. This applies to matching patterns and the filenames the patterns are applied to. If case sensitivity is applied on a Windows system, slashes will not be normalized and pattern and filenames will be treated as a Linux/Unix filename. By default, . is not matched by * , ? , and [] . See the DOTMATCH flag to match . at the start of a filename without a literal . .","title":"Syntax"},{"location":"fnmatch/#posix-character-classes","text":"A number of POSIX style character classes are available in the form [:posix:] . They must be used inside sequences: [[:posix:]] . For byte strings, the C locale is used, and the values will for each character class are found in the table below under ASCII . When used in a Unicode string, Unicode properties will be used. [:posix:] \\p{posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9]","title":"POSIX Character Classes"},{"location":"fnmatch/#api","text":"","title":"API"},{"location":"fnmatch/#fnmatchfnmatch","text":"def fnmatch ( filename , patterns , * , flags = 0 ) fnmatch takes a file name, a pattern (or list of patterns), and flags. It will return a boolean indicating whether the file name was matched by the pattern(s). >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , r '@(*.txt|*.py)' , flags = fnmatch . EXTMATCH ) True When applying multiple patterns, a file matches if it matches any of the patterns: >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , [ r '*.txt' , r '*.py' ], flags = fnmatch . EXTMATCH ) True Exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with inclusion patterns, a file will be considered matched if one of the inclusion patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , r '*|!*.py' , flags = fnmatch . NEGATE | fnamtch . SPLIT ) False >>> fnmatch . fnmatch ( 'test.txt' , r '*|!*.py' , flags = fnmatch . NEGATE | fnamtch . SPLIT ) True >>> fnmatch . fnmatch ( 'test.txt' , [ r '*.txt' , r '!avoid.txt' ], flags = fnmatch . NEGATE ) True >>> fnmatch . fnmatch ( 'avoid.txt' , [ r '*.txt' , r '!avoid.txt' ], flags = fnmatch . NEGATE ) False As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the NEGATEALL flag. Essentially, it means if you use a pattern such as !*.md , it will assume two pattern were given: * and !*.md . >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , r '!*.py' , flags = fnmatch . NEGATE | fnamtch . NEGATEALL ) False >>> fnmatch . fnmatch ( 'test.txt' , r '!*.py' , flags = fnmatch . NEGATE | fnamtch . NEGATEALL ) True","title":"fnmatch.fnmatch"},{"location":"fnmatch/#fnmatchfilter","text":"def filter ( filenames , patterns , * , flags = 0 ): filter takes a list of filenames, a pattern (or list of patterns), and flags. It returns a list of all files that matched the pattern(s). The same logic used for fnmatch is used for filter , albeit more efficient for processing multiple files. >>> from wcmatch import fnmatch >>> fnmatch . filter ([ 'a.txt' , 'b.txt' , 'c.py' ], r '*.txt' ) ['a.txt', 'b.txt']","title":"fnmatch.filter"},{"location":"fnmatch/#fnmatchtranslate","text":"def translate ( patterns , * , flags = 0 ): translate takes a file pattern (or list of patterns) and returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns. >>> from wcmatch import translate >>> fnmatch . translate ( r '*.{a,{b,c}}' , flags = fnmatch . BRACE ) (['^(?s:(?=.).*?\\\\.a)$', '^(?s:(?=.).*?\\\\.b)$', '^(?s:(?=.).*?\\\\.c)$'], []) >>> fnmatch . translate ( r '**|!*.{a,{b,c}}' , flags = fnmatch . BRACE | fnmatch . NEGATE | fnmatch . SPLIT ) (['^(?s:(?=.)(?![.]).*?)$'], ['^(?s:(?=.).*?\\\\.a)$', '^(?s:(?=.).*?\\\\.b)$', '^(?s:(?=.).*?\\\\.c)$']) Changed 4.0 Translate now outputs exclusion patterns so that if they match, the file is excluded. This is opposite logic to how it used to be, but is more efficient.","title":"fnmatch.translate"},{"location":"fnmatch/#flags","text":"","title":"Flags"},{"location":"fnmatch/#fnmatchcase","text":"CASE forces case sensitivity. CASE has higher priority than IGNORECASE . New 4.3.0 CASE is new in 4.3.0.","title":"fnmatch.CASE, fnmatch.C"},{"location":"fnmatch/#fnmatchignorecase","text":"IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE .","title":"fnmatch.IGNORECASE, fnmatch.I"},{"location":"fnmatch/#fnmatchrawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' .","title":"fnmatch.RAWCHARS, fnmatch.R"},{"location":"fnmatch/#fnmatchnegate","text":"NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would match any file but Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. If used with the extended match feature, patterns like !(inverse|pattern) will be mistakenly parsed as an exclusion pattern instead of as an inverse extended glob group. See MINUSNEGATE for an alternative syntax that plays nice with extended glob. Changes 4.0 In 4.0, NEGATE now requires a non-exclusion pattern to be paired with it or it will match nothing. If you really need something similar to the old behavior, that would assume a default inclusion pattern, you can use the NEGATEALL .","title":"fnmatch.NEGATE, fnmatch.N"},{"location":"fnmatch/#fnmatchnegateall","text":"NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: * and !*.md , where !*.md is applied to the results of * . Dot files will not be returned unless DOTMATCH .","title":"fnmatch.NEGATEALL, fnmatch.A"},{"location":"fnmatch/#fnmatchminusnegate","text":"When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the EXTMATCH option.","title":"fnmatch.MINUSNEGATE, fnmatch.M"},{"location":"fnmatch/#fnmatchdotmatch","text":"By default, fnmatch and related functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTMATCH allows the meta characters (such as * ) to match dots like any other character. Dots will not be matched in [] , * , or ? .","title":"fnmatch.DOTMATCH, fnmatch.D"},{"location":"fnmatch/#fnmatchextmatch","text":"EXTMATCH enables extended pattern matching. This includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information.","title":"fnmatch.EXTMATCH, fnmatch.E"},{"location":"fnmatch/#fnmatchbrace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns.","title":"fnmatch.BRACE, fnmatch.B"},{"location":"fnmatch/#fnmatchsplit","text":"SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the delimiters if needed: \\| . >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> fnmatch . fnmatch ( 'test.py' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True","title":"fnmatch.SPLIT, fnmatch.S"},{"location":"fnmatch/#fnmatchforcewin","text":"FORCEWIN will force Windows name and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized. This is great if you need to match Windows specific names on a Linux/Unix system. If FORCEWIN is used along side FORCEUNIX , both will be ignored. New 4.2.0 FORCEWIN is new in 4.2.0.","title":"fnmatch.FORCEWIN, fnmatch.W"},{"location":"fnmatch/#fnmatchforceunix","text":"FORCEUNIX will force Linux/Unix name and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific names on a Windows system. When using FORCEUNIX , the names are assumed to be case sensitive, but you can use IGNORECASE to use case insensitivity. If FORCEUNIX is used along side FORCEWIN , both will be ignored. New 4.2.0 FORCEUNIX is new in 4.2.0.","title":"fnmatch.FORCEUNIX, fnmatch.U"},{"location":"glob/","text":"wcmatch.glob \ue157 from wcmatch import glob Syntax \ue157 The glob library provides methods for traversing the file system and returning files that matched a defined set of glob patterns. The library also provides functions for matching file paths which is similar to fnmatch , but for paths. In short, globmatch matches what glob globs . globmatch 's features are similar to fnmatch 's. Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything except slashes. On Windows it will avoid matching backslashes as well as slashes. ** Matches zero or more directories, but will never match the directories . and .. . ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. [[:alnum:]] POSIX style character classes inside sequences. The C locale is used for byte strings and Unicode properties for Unicode strings. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character, it will be treated as a normal character. ! Exclusion pattern (with configuration, can use - instead of ! ). ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . {} Bash style brace expansions. This is applied to patterns before anything else. Slashes are generally treated special in glob related methods. Slashes are not matched in [] , * , ? , or extended patterns like *(...) . Slashes can be matched by ** if GLOBSTAR is set. On Windows, slashes will be normalized in paths and patterns: / will become \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, it will be handled properly. On Windows, drives are treated special and must come at the beginning of the pattern and cannot be matched with * , [] , ? , or even extended match patterns like +(...) . Windows drives are recognized as either C:\\ or \\\\Server\\mount\\ (or C:/ and //Server/mount/ ). If a path uses an ambiguous root ( \\some\\path or /some/path ), the system will assume the drive of the current working directory. Meta characters have no effect when inside a UNC path: \\\\\\\\Server?\\\\mount*\\\\ . If FORCEUNIX is applied on a Windows system, match and filter commands that do not touch the file system will not have slashes normalized. In addition, drive letters will also not be handled. Essentially, paths will be treated as if on Linux/Unix. Commands that do touch the file system ( glob and iglob ) will ignore FORCEUNIX and FORCEWIN . globmatch and globfilter , will also ignore FORCEUNIX and FORCEWIN if the REALPATH flag is enabled. FORCEWIN will do the opposite on a Linux/Unix system, and will force non-Windows logic on a Windows system. Like with FORCEUNIX , it only applies to commands that don't touch the file system. By default, file and directory names starting with . are only matched with literal . . The patterns * , ** , ? , and [] will not match a leading . . To alter this behavior, you can use the DOTGLOB flag, but even with DOTGLOB these special tokens will not match a special directory ( . or .. ). But when a literal . is used at the start of the filename, for instance in the pattern .* , . and .. can potentially be matched. In general, Wildcard Match's behavior is modeled off of Bash's, so unlike Python's default glob , Wildcard Match's glob will match and return . and .. in certain cases just like Bash does. Python's default: >>> import glob >>> glob . glob ( 'docs/.*' ) [] Wcmatch: >>> from wcmatch import glob >>> glob . glob ( 'docs/.*' ) ['docs/.', 'docs/..'] Bash: $ echo docs/.* docs/. docs/.. POSIX Character Classes \ue157 A number of POSIX style character classes are available in the form [:posix:] . They must be used inside sequences: [[:posix:]] . For byte strings, the C locale is used, and the values will for each character class are found in the table below under ASCII . When used in a Unicode string, Unicode properties will be used. [:posix:] \\p{posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9] API \ue157 glob.glob \ue157 def glob ( patterns , * , flags = 0 ): glob takes a pattern (or list of patterns) and will crawl the file system returning matching files. If a file/folder matches any regular patterns, it is considered a match. If it matches any exclusion pattern (when enabling the NEGATE flag), then it will be not be returned. >>> from wcmatch import glob >>> glob . glob ( r '**/*.md' ) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] We can also exclude directories and/or files: >>> from wcmatch import glob >>> glob . glob ([ r '**/*.md' , r '!README.md' , r '!**/_snippets' ], flags = glob . NEGATE ) ['docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md'] When a glob pattern ends with a slash, it will only return directories: >>> from wcmatch import glob >>> glob . glob ( r '**/' ) ['__pycache__/', 'docs/', 'docs/src/', 'docs/src/markdown/', 'docs/src/markdown/_snippets/', 'docs/theme/', 'requirements/', 'stuff/', 'tests/', 'tests/__pycache__/', 'wcmatch/', 'wcmatch/__pycache__/'] glob.iglob \ue157 def iglob ( patterns , * , flags = 0 ): iglob is just like glob except it returns an iterator. >>> from wcmatch import glob >>> list ( glob . iglob ( r '**/*.md' )) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] glob.globmatch \ue157 def globmatch ( filename , patterns , * , flags = 0 ): globmatch takes a file name, a pattern (or list of patterns), and flags. It will return a boolean indicating whether the file path was matched by the pattern(s). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , r '**/*/@(*.txt|*.py)' ) True When applying multiple patterns, a file path matches if it matches any of the patterns: >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , [ r '**/*/*.txt' , r '**/*/*.py' ]) True Exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with other patterns, a path will be considered matched if one of the positive patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves. >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.py' , r '**|!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . SPLIT ) True >>> glob . globmatch ( 'some/path/test.txt' , r '**|!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . SPLIT ) False >>> glob . globmatch ( 'some/path/test.txt' , [ r '*/*/*.txt' , r '!*/*/avoid.txt' ], flags = glob . NEGATE ) True >>> glob . globmatch ( 'some/path/avoid.txt' , [ r '*/*/*.txt' , r '!*/*/avoid.txt' ], flags = glob . NEGATE ) False As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the NEGATEALL flag. Essentially, it means if you use a pattern such as !*.md , it means if you use a pattern such as !*.md , it will assume two pattern were given: * and !*.md (where ** is specifically treated as if GLOBSTAR was enabled). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.py' , r '!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . NEGATEALL ) True >>> glob . globmatch ( 'some/path/test.txt' , r '!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . NEGATEALL ) False By default, globmatch and globfilter do not operate on the file system. This is to allow you to process paths from any source, even paths that are not on your current system. So if you are trying to explicitly match a directory with a pattern such as */ , your path must end with a slash ( my_directory/ ) to be recognized as a directory. It also won't be able to evaluate whether a directory is a symlink or not as it will have no way of checking. Here we see that globmatch fails to match the filepath as the pattern is explicitly looking for a directory and our filepath does not end with / . >>> from wcmatch import glob >>> glob . globmatch ( 'docs' , '*/' ) False If you would like for globmatch (or globfilter ) to operate on your current filesystem directly, simply pass in the REALPATH flag. When enabled, the path under consideration will be analyzed and will use that context to determine if the file exists, if it is a directory, does it's context make sense compared to what the pattern is looking vs the current working directory, or if it has symlinks that should not be matched by GLOBSTAR . Here we use REALPATH and can see that globmatch now knows that doc is a directory. >>> from wcmatch import glob >>> glob . globmatch ( 'docs' , '*/' , flags = glob . REALPATH ) True It also can tell if a file doesn't exist or is out of scope compared to what is being asked. For instance, the below example fails because the pattern is looking for any folder that is relative to the current path, which /usr is not. When we disable REALPATH , it will match just fine. Both cases can be useful depending on how you plan to use globmatch . >>> from wcmatch import glob >>> glob . globmatch ( '/usr' , '**/' , flags = glob . G | glob . REALPATH ) False >>> glob . globmatch ( '/usr' , '**/' , flags = glob . G ) True glob.globfilter \ue157 def globfilter ( filenames , patterns , * , flags = 0 ): globfilter takes a list of file paths, a pattern (or list of patterns), and flags. It returns a list of all files paths that matched the pattern(s). The same logic used for globmatch is used for globfilter , albeit more efficient for processing multiple files. >>> from wcmatch import glob >>> glob . globfilter ([ 'some/path/a.txt' , 'b.txt' , 'another/path/c.py' ], r '**/*.txt' ) ['some/path/a.txt', 'b.txt'] Like globmatch , globfilter does not operate directly on the file system, with all the caveats associated. But you can enable the REALPATH flag and globfilter will use the filesystem to gain context such as: whether the file exists, whether it is a directory or not, or whether it has symlinks that should not be matched by GLOBSTAR . See globmatch for examples. glob.translate \ue157 def translate ( patterns , * , flags = 0 ): translate takes a file pattern (or list of patterns) and returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns. >>> from wcmatch import glob >>> glob . translate ( r '**/*.{py,txt}' ) (['^(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.py[\\\\/]*?)$', '^(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.txt[\\\\/]*?)$'], []) >>> glob . translate ( r '**|!**/*.{py,txt}' , flags = glob . NEGATE | glob . SPLIT ) (['^(?s:(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?[\\\\/]*?)$'], ['^(?s:(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))[^\\\\/]*?\\\\/+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))[^\\\\/]*?\\\\.\\\\{py\\\\,txt\\\\}[\\\\/]*?)$']) Changed 4.0 Translate now outputs exclusion patterns so that if they match, the file is excluded. This is opposite logic to how it used to be, but is more efficient. glob.escape \ue157 def escape ( pattern , unix = None ): This escapes special glob meta characters so they will be treated as literal characters. It escapes using backslashes. It will escape - , ! , * , ? , ( , [ , | , ^ , { , and \\ . On Windows, it will specifically only escape \\ when not already escaped ( \\\\ ). / and \\\\ (on Windows) are not escaped as they are path separators. >>> from wcmatch import glob >>> glob . escape ( 'some/path?/**file** {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( 'some/path?/**file** {} .txt' )) True On a Windows system, drives are not escaped since meta characters are not parsed in drives. Drives on Windows are generally treated special. This is because a drive could contain special characters like in \\\\?\\c:\\ . escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, and vice versa. You can force Unix style escaping or Windows style escaping via the unix parameter. When unix is None , the escape style will be detected, when unix is True Linux/Unix style escaping will be used, and when unix is False Windows style escaping will be used. >>> glob . escape ( 'some/path?/**file** {} .txt' , platform = glob . UNIX ) New 5.0 The unix parameter is now None by default. Set to True to force Linux/Unix style escaping or set to False to force Windows style escaping. glob.raw_escape \ue157 def raw_escape ( pattern , unix = None ): This is like escape except it will apply raw character string escapes before doing meta character escapes. This is meant for use with the RAWCHARS flag. >>> from wcmatch import glob >>> glob . raw_escape ( r 'some/path?/\\x2a\\x2afile\\x2a\\x2a {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( r 'some/path?/\\x2a\\x2afile\\x2a\\x2a {} .txt' ), flags = glob . RAWCHARS ) True raw_escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, and vice versa. You can force Unix style escaping or Windows style escaping via the unix parameter. When unix is None , the escape style will be detected, when unix is True Linux/Unix style escaping will be used, and when unix is False Windows style escaping will be used. >>> glob . raw_escape ( r 'some/path?/\\x2a\\x2afile\\x2a\\x2a {} .txt' , platform = glob . UNIX ) New 5.0 The unix parameter is now None by default. Set to True to force Linux/Unix style escaping or set to False to force Windows style escaping. Flags \ue157 glob.CASE, glob.C \ue157 CASE forces case sensitivity. CASE has higher priority than IGNORECASE . On Windows, drive letters ( C: ) and UNC host/share ( //host/share ) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied. New 4.3.0 CASE is new in 4.3.0. glob.IGNORECASE, glob.I \ue157 IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE . glob.RAWCHARS, glob.R \ue157 RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' . glob.NEGATE, glob.N \ue157 NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would match any file but Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. If used with the extended glob feature, patterns like !(inverse|pattern) will be mistakenly parsed as an exclusion pattern instead of as an inverse extended glob group. See MINUSNEGATE for an alternative syntax that plays nice with extended glob. Changes 4.0 In 4.0, NEGATE now requires a non-exclusion pattern to be paired with it or it will match nothing. If you really need something similar to the old behavior, that would assume a default inclusion pattern, you can use the NEGATEALL . glob.NEGATEALL, glob.A \ue157 NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: ** and !*.md , where !*.md is applied to the results of ** , and ** is specifically treated as if GLOBSTAR was enabled. Dot files will not be returned unless DOTGLOB is enabled. Symlinks will also be ignored in the return unless FOLLOW is enabled. glob.MINUSNEGATE, glob.M \ue157 When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) . glob.GLOBSTAR, glob.G \ue157 GLOBSTAR enables the feature where ** matches zero or more directories. New 3.0 GLOBSTAR will no longer match or traverse symlink directories. This models the recent behavior in Bash 5.0. To crawl symlink directories, the new FOLLOW flag must be enabled. glob.FOLLOW, glob.FL \ue157 FOLLOW will cause GLOBSTAR patterns ( ** ) to match and traverse symlink directories. New 3.0 FOLLOW was added in 3.0. glob.REALPATH, glob.P \ue157 In the past, only glob and iglob operated on the filesystem, but with REALPATH , other functions will now operate on the filesystem as well: globmatch and globfilter . Normally, functions such as globmatch would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system. REALPATH forces globmatch and globfilter to treat the string path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match: Path must exist. Directories that are symlinks will not be matched by GLOBSTAR patterns ( ** ) unless the FOLLOW flag is enabled. When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a directory. Paths must match in relation to the current working directory unless the pattern is constructed in a way to indicates an absolute path. Since REALPATH causes the file system to be referenced when matching a path, flags such as FORCEUNIX and FORCEWIN are not allowed with this flag and will be ignored. NEW 3.0 REALPATH was added in 3.0. glob.DOTGLOB, glob.D \ue157 By default, glob and globmatch will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , or ? . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash. glob.EXTGLOB, glob.E \ue157 EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash. glob.BRACE, glob.B \ue157 BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns. glob.SPLIT, glob.S \ue157 SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the delimiters if needed: \\| . >>> from wcmatch import glob >>> glob . globmatch ( 'test.txt' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> glob . globmatch ( 'test.py' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True glob.MARK, glob.K \ue157 MARK ensures that glob and iglob to return all directories with a trailing slash. This makes it very clear which paths are directories and allows you to save calling os.path.isdir as you can simply check for a path separator at the end of the path. This flag only applies to calls to glob or iglob . If you are passing the returned files from glob to globfilter or globmatch , it is important to ensure directory paths have trailing slashes as these functions have no way of telling the path is a directory otherwise (except when REALPATH is enabled). If you have REALPATH enabled, ensuring the files have trailing slashes can still save you a call to os.path.isdir as REALPATH resorts to calling it if there is no trailing slash. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . MARK ) ['appveyor.yml', 'base.patch', 'basematch.diff', 'docs/', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements/', 'setup.cfg', 'setup.py', 'tests/', 'tools/', 'tox.ini', 'wcmatch/'] >>> glob . glob ( '*' ) ['appveyor.yml', 'base.patch', 'basematch.diff', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'tests', 'tools', 'tox.ini', 'wcmatch'] New 4.0 MARK added in 4.0. glob.MATCHBASE, glob.X \ue157 MATCHBASE , when a pattern has no slashes in it, will cause glob and iglob to seek for any file anywhere in the tree with a matching basename. When enabled for globfilter and globmatch , any path whose basename matches. >>> from wcmatch import glob >>> glob . glob ( '*.txt' , flags = glob . MATCHBASE ) ['docs/src/dictionary/en-custom.txt', 'docs/src/markdown/_snippets/abbr.txt', 'docs/src/markdown/_snippets/links.txt', 'docs/src/markdown/_snippets/posix.txt', 'docs/src/markdown/_snippets/refs.txt', 'requirements/docs.txt', 'requirements/lint.txt', 'requirements/setup.txt', 'requirements/test.txt', 'requirements/tools.txt'] New 4.0 MATCHBASE added in 4.0. glob.NODIR, glob.O \ue157 NODIR will cause glob , iglob , globmatch , and globfilter to return only matched files. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . NODIR ) ['appveyor.yml', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'setup.cfg', 'setup.py', 'spell.log', 'tox.ini'] >>> glob . glob ( '*' ) ['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'spell.log', 'tests', 'tools', 'tox.ini', 'wcmatch'] glob.FORCEWIN, glob.W \ue157 FORCEWIN will force Windows path and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized and Windows drive syntax to be handled special. This is great if you need to match Windows specific paths on a Linux/Unix system. This will only work on commands that do not access the file system: translate , globmatch , globfilter , etc. These flags will not work with glob or iglob . It also will not work when using the REALPATH flag with things like globmatch and globfilter . If FORCEWIN is used along side FORCEUNIX , both will be ignored. New 4.2.0 FORCEWIN is new in 4.2.0. glob.FORCEUNIX, glob.U \ue157 FORCEUNIX will force Linux/Unix path and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific paths on a Windows system. This will only work on commands that do not access the file system: translate , globmatch , globfilter , etc. These flags will not work with glob or iglob . It also will not work when using the REALPATH flag with things like globmatch and globfilter . When using FORCEUNIX , the paths are assumed to be case sensitive, but you can use IGNORECASE to use case insensitivity. If FORCEUNIX is used along side FORCEWIN , both will be ignored. New 4.2.0 FORCEUNIX is new in 4.2.0.","title":"Glob"},{"location":"glob/#wcmatchglob","text":"from wcmatch import glob","title":"wcmatch.glob"},{"location":"glob/#syntax","text":"The glob library provides methods for traversing the file system and returning files that matched a defined set of glob patterns. The library also provides functions for matching file paths which is similar to fnmatch , but for paths. In short, globmatch matches what glob globs . globmatch 's features are similar to fnmatch 's. Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything except slashes. On Windows it will avoid matching backslashes as well as slashes. ** Matches zero or more directories, but will never match the directories . and .. . ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. [[:alnum:]] POSIX style character classes inside sequences. The C locale is used for byte strings and Unicode properties for Unicode strings. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character, it will be treated as a normal character. ! Exclusion pattern (with configuration, can use - instead of ! ). ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . {} Bash style brace expansions. This is applied to patterns before anything else. Slashes are generally treated special in glob related methods. Slashes are not matched in [] , * , ? , or extended patterns like *(...) . Slashes can be matched by ** if GLOBSTAR is set. On Windows, slashes will be normalized in paths and patterns: / will become \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, it will be handled properly. On Windows, drives are treated special and must come at the beginning of the pattern and cannot be matched with * , [] , ? , or even extended match patterns like +(...) . Windows drives are recognized as either C:\\ or \\\\Server\\mount\\ (or C:/ and //Server/mount/ ). If a path uses an ambiguous root ( \\some\\path or /some/path ), the system will assume the drive of the current working directory. Meta characters have no effect when inside a UNC path: \\\\\\\\Server?\\\\mount*\\\\ . If FORCEUNIX is applied on a Windows system, match and filter commands that do not touch the file system will not have slashes normalized. In addition, drive letters will also not be handled. Essentially, paths will be treated as if on Linux/Unix. Commands that do touch the file system ( glob and iglob ) will ignore FORCEUNIX and FORCEWIN . globmatch and globfilter , will also ignore FORCEUNIX and FORCEWIN if the REALPATH flag is enabled. FORCEWIN will do the opposite on a Linux/Unix system, and will force non-Windows logic on a Windows system. Like with FORCEUNIX , it only applies to commands that don't touch the file system. By default, file and directory names starting with . are only matched with literal . . The patterns * , ** , ? , and [] will not match a leading . . To alter this behavior, you can use the DOTGLOB flag, but even with DOTGLOB these special tokens will not match a special directory ( . or .. ). But when a literal . is used at the start of the filename, for instance in the pattern .* , . and .. can potentially be matched. In general, Wildcard Match's behavior is modeled off of Bash's, so unlike Python's default glob , Wildcard Match's glob will match and return . and .. in certain cases just like Bash does. Python's default: >>> import glob >>> glob . glob ( 'docs/.*' ) [] Wcmatch: >>> from wcmatch import glob >>> glob . glob ( 'docs/.*' ) ['docs/.', 'docs/..'] Bash: $ echo docs/.* docs/. docs/..","title":"Syntax"},{"location":"glob/#posix-character-classes","text":"A number of POSIX style character classes are available in the form [:posix:] . They must be used inside sequences: [[:posix:]] . For byte strings, the C locale is used, and the values will for each character class are found in the table below under ASCII . When used in a Unicode string, Unicode properties will be used. [:posix:] \\p{posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9]","title":"POSIX Character Classes"},{"location":"glob/#api","text":"","title":"API"},{"location":"glob/#globglob","text":"def glob ( patterns , * , flags = 0 ): glob takes a pattern (or list of patterns) and will crawl the file system returning matching files. If a file/folder matches any regular patterns, it is considered a match. If it matches any exclusion pattern (when enabling the NEGATE flag), then it will be not be returned. >>> from wcmatch import glob >>> glob . glob ( r '**/*.md' ) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] We can also exclude directories and/or files: >>> from wcmatch import glob >>> glob . glob ([ r '**/*.md' , r '!README.md' , r '!**/_snippets' ], flags = glob . NEGATE ) ['docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md'] When a glob pattern ends with a slash, it will only return directories: >>> from wcmatch import glob >>> glob . glob ( r '**/' ) ['__pycache__/', 'docs/', 'docs/src/', 'docs/src/markdown/', 'docs/src/markdown/_snippets/', 'docs/theme/', 'requirements/', 'stuff/', 'tests/', 'tests/__pycache__/', 'wcmatch/', 'wcmatch/__pycache__/']","title":"glob.glob"},{"location":"glob/#globiglob","text":"def iglob ( patterns , * , flags = 0 ): iglob is just like glob except it returns an iterator. >>> from wcmatch import glob >>> list ( glob . iglob ( r '**/*.md' )) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md']","title":"glob.iglob"},{"location":"glob/#globglobmatch","text":"def globmatch ( filename , patterns , * , flags = 0 ): globmatch takes a file name, a pattern (or list of patterns), and flags. It will return a boolean indicating whether the file path was matched by the pattern(s). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , r '**/*/@(*.txt|*.py)' ) True When applying multiple patterns, a file path matches if it matches any of the patterns: >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , [ r '**/*/*.txt' , r '**/*/*.py' ]) True Exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with other patterns, a path will be considered matched if one of the positive patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves. >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.py' , r '**|!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . SPLIT ) True >>> glob . globmatch ( 'some/path/test.txt' , r '**|!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . SPLIT ) False >>> glob . globmatch ( 'some/path/test.txt' , [ r '*/*/*.txt' , r '!*/*/avoid.txt' ], flags = glob . NEGATE ) True >>> glob . globmatch ( 'some/path/avoid.txt' , [ r '*/*/*.txt' , r '!*/*/avoid.txt' ], flags = glob . NEGATE ) False As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the NEGATEALL flag. Essentially, it means if you use a pattern such as !*.md , it means if you use a pattern such as !*.md , it will assume two pattern were given: * and !*.md (where ** is specifically treated as if GLOBSTAR was enabled). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.py' , r '!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . NEGATEALL ) True >>> glob . globmatch ( 'some/path/test.txt' , r '!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . NEGATEALL ) False By default, globmatch and globfilter do not operate on the file system. This is to allow you to process paths from any source, even paths that are not on your current system. So if you are trying to explicitly match a directory with a pattern such as */ , your path must end with a slash ( my_directory/ ) to be recognized as a directory. It also won't be able to evaluate whether a directory is a symlink or not as it will have no way of checking. Here we see that globmatch fails to match the filepath as the pattern is explicitly looking for a directory and our filepath does not end with / . >>> from wcmatch import glob >>> glob . globmatch ( 'docs' , '*/' ) False If you would like for globmatch (or globfilter ) to operate on your current filesystem directly, simply pass in the REALPATH flag. When enabled, the path under consideration will be analyzed and will use that context to determine if the file exists, if it is a directory, does it's context make sense compared to what the pattern is looking vs the current working directory, or if it has symlinks that should not be matched by GLOBSTAR . Here we use REALPATH and can see that globmatch now knows that doc is a directory. >>> from wcmatch import glob >>> glob . globmatch ( 'docs' , '*/' , flags = glob . REALPATH ) True It also can tell if a file doesn't exist or is out of scope compared to what is being asked. For instance, the below example fails because the pattern is looking for any folder that is relative to the current path, which /usr is not. When we disable REALPATH , it will match just fine. Both cases can be useful depending on how you plan to use globmatch . >>> from wcmatch import glob >>> glob . globmatch ( '/usr' , '**/' , flags = glob . G | glob . REALPATH ) False >>> glob . globmatch ( '/usr' , '**/' , flags = glob . G ) True","title":"glob.globmatch"},{"location":"glob/#globglobfilter","text":"def globfilter ( filenames , patterns , * , flags = 0 ): globfilter takes a list of file paths, a pattern (or list of patterns), and flags. It returns a list of all files paths that matched the pattern(s). The same logic used for globmatch is used for globfilter , albeit more efficient for processing multiple files. >>> from wcmatch import glob >>> glob . globfilter ([ 'some/path/a.txt' , 'b.txt' , 'another/path/c.py' ], r '**/*.txt' ) ['some/path/a.txt', 'b.txt'] Like globmatch , globfilter does not operate directly on the file system, with all the caveats associated. But you can enable the REALPATH flag and globfilter will use the filesystem to gain context such as: whether the file exists, whether it is a directory or not, or whether it has symlinks that should not be matched by GLOBSTAR . See globmatch for examples.","title":"glob.globfilter"},{"location":"glob/#globtranslate","text":"def translate ( patterns , * , flags = 0 ): translate takes a file pattern (or list of patterns) and returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns. >>> from wcmatch import glob >>> glob . translate ( r '**/*.{py,txt}' ) (['^(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.py[\\\\/]*?)$', '^(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.txt[\\\\/]*?)$'], []) >>> glob . translate ( r '**|!**/*.{py,txt}' , flags = glob . NEGATE | glob . SPLIT ) (['^(?s:(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?[\\\\/]*?)$'], ['^(?s:(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))[^\\\\/]*?\\\\/+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))[^\\\\/]*?\\\\.\\\\{py\\\\,txt\\\\}[\\\\/]*?)$']) Changed 4.0 Translate now outputs exclusion patterns so that if they match, the file is excluded. This is opposite logic to how it used to be, but is more efficient.","title":"glob.translate"},{"location":"glob/#globescape","text":"def escape ( pattern , unix = None ): This escapes special glob meta characters so they will be treated as literal characters. It escapes using backslashes. It will escape - , ! , * , ? , ( , [ , | , ^ , { , and \\ . On Windows, it will specifically only escape \\ when not already escaped ( \\\\ ). / and \\\\ (on Windows) are not escaped as they are path separators. >>> from wcmatch import glob >>> glob . escape ( 'some/path?/**file** {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( 'some/path?/**file** {} .txt' )) True On a Windows system, drives are not escaped since meta characters are not parsed in drives. Drives on Windows are generally treated special. This is because a drive could contain special characters like in \\\\?\\c:\\ . escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, and vice versa. You can force Unix style escaping or Windows style escaping via the unix parameter. When unix is None , the escape style will be detected, when unix is True Linux/Unix style escaping will be used, and when unix is False Windows style escaping will be used. >>> glob . escape ( 'some/path?/**file** {} .txt' , platform = glob . UNIX ) New 5.0 The unix parameter is now None by default. Set to True to force Linux/Unix style escaping or set to False to force Windows style escaping.","title":"glob.escape"},{"location":"glob/#globraw_escape","text":"def raw_escape ( pattern , unix = None ): This is like escape except it will apply raw character string escapes before doing meta character escapes. This is meant for use with the RAWCHARS flag. >>> from wcmatch import glob >>> glob . raw_escape ( r 'some/path?/\\x2a\\x2afile\\x2a\\x2a {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( r 'some/path?/\\x2a\\x2afile\\x2a\\x2a {} .txt' ), flags = glob . RAWCHARS ) True raw_escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, and vice versa. You can force Unix style escaping or Windows style escaping via the unix parameter. When unix is None , the escape style will be detected, when unix is True Linux/Unix style escaping will be used, and when unix is False Windows style escaping will be used. >>> glob . raw_escape ( r 'some/path?/\\x2a\\x2afile\\x2a\\x2a {} .txt' , platform = glob . UNIX ) New 5.0 The unix parameter is now None by default. Set to True to force Linux/Unix style escaping or set to False to force Windows style escaping.","title":"glob.raw_escape"},{"location":"glob/#flags","text":"","title":"Flags"},{"location":"glob/#globcase","text":"CASE forces case sensitivity. CASE has higher priority than IGNORECASE . On Windows, drive letters ( C: ) and UNC host/share ( //host/share ) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied. New 4.3.0 CASE is new in 4.3.0.","title":"glob.CASE, glob.C"},{"location":"glob/#globignorecase","text":"IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE .","title":"glob.IGNORECASE, glob.I"},{"location":"glob/#globrawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' .","title":"glob.RAWCHARS, glob.R"},{"location":"glob/#globnegate","text":"NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would match any file but Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. If used with the extended glob feature, patterns like !(inverse|pattern) will be mistakenly parsed as an exclusion pattern instead of as an inverse extended glob group. See MINUSNEGATE for an alternative syntax that plays nice with extended glob. Changes 4.0 In 4.0, NEGATE now requires a non-exclusion pattern to be paired with it or it will match nothing. If you really need something similar to the old behavior, that would assume a default inclusion pattern, you can use the NEGATEALL .","title":"glob.NEGATE, glob.N"},{"location":"glob/#globnegateall","text":"NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: ** and !*.md , where !*.md is applied to the results of ** , and ** is specifically treated as if GLOBSTAR was enabled. Dot files will not be returned unless DOTGLOB is enabled. Symlinks will also be ignored in the return unless FOLLOW is enabled.","title":"glob.NEGATEALL, glob.A"},{"location":"glob/#globminusnegate","text":"When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) .","title":"glob.MINUSNEGATE, glob.M"},{"location":"glob/#globglobstar","text":"GLOBSTAR enables the feature where ** matches zero or more directories. New 3.0 GLOBSTAR will no longer match or traverse symlink directories. This models the recent behavior in Bash 5.0. To crawl symlink directories, the new FOLLOW flag must be enabled.","title":"glob.GLOBSTAR, glob.G"},{"location":"glob/#globfollow","text":"FOLLOW will cause GLOBSTAR patterns ( ** ) to match and traverse symlink directories. New 3.0 FOLLOW was added in 3.0.","title":"glob.FOLLOW, glob.FL"},{"location":"glob/#globrealpath","text":"In the past, only glob and iglob operated on the filesystem, but with REALPATH , other functions will now operate on the filesystem as well: globmatch and globfilter . Normally, functions such as globmatch would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system. REALPATH forces globmatch and globfilter to treat the string path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match: Path must exist. Directories that are symlinks will not be matched by GLOBSTAR patterns ( ** ) unless the FOLLOW flag is enabled. When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a directory. Paths must match in relation to the current working directory unless the pattern is constructed in a way to indicates an absolute path. Since REALPATH causes the file system to be referenced when matching a path, flags such as FORCEUNIX and FORCEWIN are not allowed with this flag and will be ignored. NEW 3.0 REALPATH was added in 3.0.","title":"glob.REALPATH, glob.P"},{"location":"glob/#globdotglob","text":"By default, glob and globmatch will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , or ? . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash.","title":"glob.DOTGLOB, glob.D"},{"location":"glob/#globextglob","text":"EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash.","title":"glob.EXTGLOB, glob.E"},{"location":"glob/#globbrace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns.","title":"glob.BRACE, glob.B"},{"location":"glob/#globsplit","text":"SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the delimiters if needed: \\| . >>> from wcmatch import glob >>> glob . globmatch ( 'test.txt' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> glob . globmatch ( 'test.py' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True","title":"glob.SPLIT, glob.S"},{"location":"glob/#globmark","text":"MARK ensures that glob and iglob to return all directories with a trailing slash. This makes it very clear which paths are directories and allows you to save calling os.path.isdir as you can simply check for a path separator at the end of the path. This flag only applies to calls to glob or iglob . If you are passing the returned files from glob to globfilter or globmatch , it is important to ensure directory paths have trailing slashes as these functions have no way of telling the path is a directory otherwise (except when REALPATH is enabled). If you have REALPATH enabled, ensuring the files have trailing slashes can still save you a call to os.path.isdir as REALPATH resorts to calling it if there is no trailing slash. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . MARK ) ['appveyor.yml', 'base.patch', 'basematch.diff', 'docs/', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements/', 'setup.cfg', 'setup.py', 'tests/', 'tools/', 'tox.ini', 'wcmatch/'] >>> glob . glob ( '*' ) ['appveyor.yml', 'base.patch', 'basematch.diff', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'tests', 'tools', 'tox.ini', 'wcmatch'] New 4.0 MARK added in 4.0.","title":"glob.MARK, glob.K"},{"location":"glob/#globmatchbase","text":"MATCHBASE , when a pattern has no slashes in it, will cause glob and iglob to seek for any file anywhere in the tree with a matching basename. When enabled for globfilter and globmatch , any path whose basename matches. >>> from wcmatch import glob >>> glob . glob ( '*.txt' , flags = glob . MATCHBASE ) ['docs/src/dictionary/en-custom.txt', 'docs/src/markdown/_snippets/abbr.txt', 'docs/src/markdown/_snippets/links.txt', 'docs/src/markdown/_snippets/posix.txt', 'docs/src/markdown/_snippets/refs.txt', 'requirements/docs.txt', 'requirements/lint.txt', 'requirements/setup.txt', 'requirements/test.txt', 'requirements/tools.txt'] New 4.0 MATCHBASE added in 4.0.","title":"glob.MATCHBASE, glob.X"},{"location":"glob/#globnodir","text":"NODIR will cause glob , iglob , globmatch , and globfilter to return only matched files. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . NODIR ) ['appveyor.yml', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'setup.cfg', 'setup.py', 'spell.log', 'tox.ini'] >>> glob . glob ( '*' ) ['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'spell.log', 'tests', 'tools', 'tox.ini', 'wcmatch']","title":"glob.NODIR, glob.O"},{"location":"glob/#globforcewin","text":"FORCEWIN will force Windows path and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized and Windows drive syntax to be handled special. This is great if you need to match Windows specific paths on a Linux/Unix system. This will only work on commands that do not access the file system: translate , globmatch , globfilter , etc. These flags will not work with glob or iglob . It also will not work when using the REALPATH flag with things like globmatch and globfilter . If FORCEWIN is used along side FORCEUNIX , both will be ignored. New 4.2.0 FORCEWIN is new in 4.2.0.","title":"glob.FORCEWIN, glob.W"},{"location":"glob/#globforceunix","text":"FORCEUNIX will force Linux/Unix path and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific paths on a Windows system. This will only work on commands that do not access the file system: translate , globmatch , globfilter , etc. These flags will not work with glob or iglob . It also will not work when using the REALPATH flag with things like globmatch and globfilter . When using FORCEUNIX , the paths are assumed to be case sensitive, but you can use IGNORECASE to use case insensitivity. If FORCEUNIX is used along side FORCEWIN , both will be ignored. New 4.2.0 FORCEUNIX is new in 4.2.0.","title":"glob.FORCEUNIX, glob.U"},{"location":"license/","text":"License \ue157 Wildcard Match \ue157 The MIT License (MIT) Copyright \u00a9 2018 - 2019 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"","title":"License"},{"location":"license/#wildcard-match","text":"The MIT License (MIT) Copyright \u00a9 2018 - 2019 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Wildcard Match"},{"location":"pathlib/","text":"wcmatch.pathlib \ue157 from wcmatch import pathlib New 5.0 wcmatch.pathlib was added in wcmatch 5.0. Overview \ue157 pathlib is a library that contains subclasses of Python's pathlib Path and PurePath classes, and their Posix and Windows subclasses, with the purpose of overriding the default glob behavior with Wildcard Match's very own glob . This allows a user of pathlib to use all of the glob enhancements that Wildcard Match provides. This includes features such as extended glob patterns, brace expansions, and more. This documentation does not mean to exhaustively describe the pathlib library, just the differences introduced by Wildcard Match's implementation. Please check out Python's pathlib documentation to learn more about pathlib in general. Also, to learn more about the underlying glob library being used, check out the documentation for Wildcard Match's glob . The API is the same as Python's default pathlib except for the few differences related to file globbing and matching: Each pathlib object's glob , rglob , and match methods are now driven by the wcmatch.glob library. glob and rglob can take a single string pattern or a list of patterns. They also accept flags via the flags keyword. This matches the interfaces found detailed in wcmatch.glob . A globmatch method has been added to PurePath classes (and Path classes which are derived from PurePath ) which is like match except without the recursive behavior. See match and globmatch for more information. glob and rglob do not enable GLOBSTAR or DOTGLOB by default. These flags must be passed in to take advantage of this functionality. As far as similarities, glob , rglob , and match should mimic the basic behavior of Python's original pathlib library, just with the enhancements and configurability that Wildcard Match's glob provides: glob and rglob will yield an iterator of the results. rglob and match will exhibit the same recursive type behavior as the original implementation. Classes \ue157 pathlib.PurePath \ue157 PurePath is Wildcard Match's version of Python's PurePath class. Depending on the system, it will create either a PureWindowsPath or a PurePosixPath object. Both objects will utilize wcmatch.glob for all glob related actions. PurePath objects do not touch the filesystem. They include the methods match and globmatch (amongst others). You can force the path to access the filesystem if you give either function the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. >>> from wcmatch import pathlib >>> pathlib . PurePath ( 'docs/src' ) PurePosixPath('docs/src') PurePath classes implement the match and globmatch methods: >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . match ( 'src' ) True >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True pathlib.PureWindowsPath \ue157 PureWindowsPath is Wildcard Match's version of Python's PureWindowsPath . The PureWindowsPath class is useful if you'd like to have the ease that pathlib offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Windows paths on a Posix system. This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from PurePath . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . PureWindowsPath ( 'c:/some/path' ) PureWindowsPath('c:/some/path') pathlib.PurePosixPath \ue157 PurePosixPath is Wildcard Match's version of Python's PurePosixPath . The PurePosixPath class is useful if you'd like to have the ease that pathlib offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Posix paths on a Windows system. This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from PurePath . >>> from wcmatch import pathlib >>> os . name 'nt' >>> pathlib . PureWindowsPath ( '/usr/local/bin' ) PurePosixPath('/usr/local/bin') pathlib.Path \ue157 Path is Wildcard Match's version of Python's Path class. Depending on the system, it will create either a WindowsPath or a PosixPath object. Both objects will utilize wcmatch.glob for all glob related actions. Path classes are subclassed from the PurePath objects, so you get all the features of the Path class in addition to the PurePath class features. Path objects have access to the filesystem. They include the PurePath methods match and globmatch (amongst others). Since these methods are PurePath methods, they do not touch the filesystem. But, you can force them to access the filesystem if you give either function the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. >>> from wcmatch import pathlib >>> pathlib . PurePath ( 'docs/src' ) PosixPath('docs/src') Path classes implement the glob and globmatch methods: >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> p . match ( 'src' ) True >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True >>> list ( p . glob ( '**/*.txt' , flags = pathlib . GLOBSTAR )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] >>> list ( p . rglob ( '*.txt' )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] pathlib.WindowsPath \ue157 WindowsPath is Wildcard Match's version of Python's WindowsPath . The WindowsPath class is useful if you'd like to have the ease that pathlib offers when working with a path and be able to manipulate or gain access to to information about that file. You cannot instantiate this class on a Posix system. This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from Path . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . Path ( 'c:/some/path' ) WindowsPath('c:/some/path') pathlib.PosixPath \ue157 PosixPath is Wildcard Match's version of Python's PosixPath . This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from pathlib.Path . PosixPath is Wildcard Match's version of Python's PosixPath . The PosixPath class is useful if you'd like to have the ease that pathlib offers when working with a path and be able to manipulate or gain access to to information about that file. You cannot instantiate this class on a Windows system. This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from Path . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . Path ( '/usr/local/bin' ) PosixPath('/usr/local/bin') Methods \ue157 PurePath.match \ue157 def match ( self , patterns , * , flags = 0 ): match takes a pattern (or list of patterns), and flags. It will return a boolean indicating whether the objects file path was matched by the pattern(s). match mimics Python's pathlib version of match in that it uses a recursive logic. What this means is when you are matching a path in the form some/path/name , the patterns name , path/name and some/path/name will all match. Essentially, the pattern, if not an absolute pattern, behaves as if a GLOBSTAR pattern of **/ was added at the beginning of the pattern. match does not access the filesystem, but you can force the path to access the filesystem if you give it the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. Since Path is derived from PurePath , this method is also available in Path objects. >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . match ( 'src' ) True PurePath.globmatch \ue157 def globmatch ( self , patterns , * , flags = 0 ): globmatch takes a pattern (or list of patterns), and flags. It will return a boolean indicating whether the objects file path was matched by the pattern(s). globmatch is similar to match except it does not use the same recursive logic that match does. In all other respects, it behaves the same. globmatch does not access the filesystem, but you can force the path to access the filesystem if you give it the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. Since Path is derived from PurePath , this method is also available in Path objects. >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True Path.rglob \ue157 def rglob ( self , patterns , * , flags = 0 ): rglob takes a pattern (or list of patterns) and will crawl the file system returning matching files. If a file/folder matches any regular patterns, it is considered a match. If a file matches any exclusion pattern (when enabling the NEGATE flag), then it will be not be returned. rglob mimics Python's pathlib version of rglob in that it uses a recursive logic. What this means is when you are matching a path in the form some/path/name , the patterns name , path/name and some/path/name will all match. Essentially, the pattern behaves as if a GLOBSTAR pattern of **/ was added at the beginning of the pattern. All paths returned are relative to the pathlib object. For this reason, absolute patterns are not supported. >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> list ( p . rglob ( '*.txt' )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] Path.glob \ue157 def glob ( self , patterns , * , flags = 0 ): glob takes a pattern (or list of patterns) and will crawl the file system returning matching files. If a file/folder matches any regular patterns, it is considered a match. If a file matches any exclusion pattern (when enabling the NEGATE flag), then it will be not be returned. glob is similar to rglob except it does not use the same recursive logic that rglob does. In all other respects, it behaves the same. All paths returned are relative to the pathlib object. For this reason, absolute patterns are not supported. >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> list ( p . glob ( '**/*.txt' , flags = pathlib . GLOBSTAR )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] Flags \ue157 pathlib.CASE, pathlib.C \ue157 CASE forces case sensitivity. CASE has higher priority than IGNORECASE . On Windows, drive letters ( C: ) and UNC host/share ( //host/share ) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied. pathlib.IGNORECASE, pathlib.I \ue157 IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE . glob.RAWCHARS, glob.R \ue157 RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' . pathlib.NEGATE, pathlib.N \ue157 NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would match any file but Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. If used with the extended glob feature, patterns like !(inverse|pattern) will be mistakenly parsed as an exclusion pattern instead of as an inverse extended glob group. See MINUSNEGATE for an alternative syntax that plays nice with extended glob. pathlib.NEGATEALL, pathlib.A \ue157 NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: ** and !*.md , where !*.md is applied to the results of ** , and ** is specifically treated as if GLOBSTAR was enabled. Dot files will not be returned unless DOTGLOB is enabled. Symlinks will also be ignored in the return unless FOLLOW is enabled. pathlib.MINUSNEGATE, pathlib.M \ue157 When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) . pathlib.GLOBSTAR, pathlib.G \ue157 GLOBSTAR enables the feature where ** matches zero or more directories. pathlib.FOLLOW, pathlib.FL \ue157 FOLLOW will cause GLOBSTAR patterns ( ** ) to match and traverse symlink directories. pathlib.REALPATH, pathlib.P \ue157 In the past, only glob and iglob operated on the filesystem, but with REALPATH , other functions will now operate on the filesystem as well: globmatch and match . Normally, functions such as globmatch would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system. REALPATH forces globmatch and match to treat the path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match: Path must exist. Directories that are symlinks will not be matched by GLOBSTAR patterns ( ** ) unless the FOLLOW flag is enabled. When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a directory. Paths must match in relation to the current working directory unless the pattern is constructed in a way to indicates an absolute path. pathlib.DOTGLOB, pathlib.D \ue157 By default, globbing and matching functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , or ? . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash. pathlib.EXTGLOB, pathlib.E \ue157 EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash. pathlib.BRACE, pathlib.B \ue157 BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns. pathlib.SPLIT, pathlib.S \ue157 SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the delimiters if needed: \\| . >>> from wcmatch import glob >>> glob . globmatch ( 'test.txt' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> glob . globmatch ( 'test.py' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True pathlib.MATCHBASE, pathlib.X \ue157 MATCHBASE , when a pattern has no slashes in it, will cause all glob related functions to seek for any file anywhere in the tree with a matching basename, or in the case of match and globmatch , path whose basename matches. >>> from wcmatch import glob >>> glob . glob ( '*.txt' , flags = glob . MATCHBASE ) ['docs/src/dictionary/en-custom.txt', 'docs/src/markdown/_snippets/abbr.txt', 'docs/src/markdown/_snippets/links.txt', 'docs/src/markdown/_snippets/posix.txt', 'docs/src/markdown/_snippets/refs.txt', 'requirements/docs.txt', 'requirements/lint.txt', 'requirements/setup.txt', 'requirements/test.txt', 'requirements/tools.txt'] pathlib.NODIR, pathlib.O \ue157 NODIR will cause all glob related functions to return only matched files. In the case of PurePath classes, this may not be possible as those classes do not access the file system, nor will they retain trailing slashes. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . NODIR ) ['appveyor.yml', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'setup.cfg', 'setup.py', 'spell.log', 'tox.ini'] >>> glob . glob ( '*' ) ['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'spell.log', 'tests', 'tools', 'tox.ini', 'wcmatch']","title":"Pathlib"},{"location":"pathlib/#wcmatchpathlib","text":"from wcmatch import pathlib New 5.0 wcmatch.pathlib was added in wcmatch 5.0.","title":"wcmatch.pathlib"},{"location":"pathlib/#overview","text":"pathlib is a library that contains subclasses of Python's pathlib Path and PurePath classes, and their Posix and Windows subclasses, with the purpose of overriding the default glob behavior with Wildcard Match's very own glob . This allows a user of pathlib to use all of the glob enhancements that Wildcard Match provides. This includes features such as extended glob patterns, brace expansions, and more. This documentation does not mean to exhaustively describe the pathlib library, just the differences introduced by Wildcard Match's implementation. Please check out Python's pathlib documentation to learn more about pathlib in general. Also, to learn more about the underlying glob library being used, check out the documentation for Wildcard Match's glob . The API is the same as Python's default pathlib except for the few differences related to file globbing and matching: Each pathlib object's glob , rglob , and match methods are now driven by the wcmatch.glob library. glob and rglob can take a single string pattern or a list of patterns. They also accept flags via the flags keyword. This matches the interfaces found detailed in wcmatch.glob . A globmatch method has been added to PurePath classes (and Path classes which are derived from PurePath ) which is like match except without the recursive behavior. See match and globmatch for more information. glob and rglob do not enable GLOBSTAR or DOTGLOB by default. These flags must be passed in to take advantage of this functionality. As far as similarities, glob , rglob , and match should mimic the basic behavior of Python's original pathlib library, just with the enhancements and configurability that Wildcard Match's glob provides: glob and rglob will yield an iterator of the results. rglob and match will exhibit the same recursive type behavior as the original implementation.","title":"Overview"},{"location":"pathlib/#classes","text":"","title":"Classes"},{"location":"pathlib/#pathlibpurepath","text":"PurePath is Wildcard Match's version of Python's PurePath class. Depending on the system, it will create either a PureWindowsPath or a PurePosixPath object. Both objects will utilize wcmatch.glob for all glob related actions. PurePath objects do not touch the filesystem. They include the methods match and globmatch (amongst others). You can force the path to access the filesystem if you give either function the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. >>> from wcmatch import pathlib >>> pathlib . PurePath ( 'docs/src' ) PurePosixPath('docs/src') PurePath classes implement the match and globmatch methods: >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . match ( 'src' ) True >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True","title":"pathlib.PurePath"},{"location":"pathlib/#pathlibpurewindowspath","text":"PureWindowsPath is Wildcard Match's version of Python's PureWindowsPath . The PureWindowsPath class is useful if you'd like to have the ease that pathlib offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Windows paths on a Posix system. This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from PurePath . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . PureWindowsPath ( 'c:/some/path' ) PureWindowsPath('c:/some/path')","title":"pathlib.PureWindowsPath"},{"location":"pathlib/#pathlibpureposixpath","text":"PurePosixPath is Wildcard Match's version of Python's PurePosixPath . The PurePosixPath class is useful if you'd like to have the ease that pathlib offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Posix paths on a Windows system. This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from PurePath . >>> from wcmatch import pathlib >>> os . name 'nt' >>> pathlib . PureWindowsPath ( '/usr/local/bin' ) PurePosixPath('/usr/local/bin')","title":"pathlib.PurePosixPath"},{"location":"pathlib/#pathlibpath","text":"Path is Wildcard Match's version of Python's Path class. Depending on the system, it will create either a WindowsPath or a PosixPath object. Both objects will utilize wcmatch.glob for all glob related actions. Path classes are subclassed from the PurePath objects, so you get all the features of the Path class in addition to the PurePath class features. Path objects have access to the filesystem. They include the PurePath methods match and globmatch (amongst others). Since these methods are PurePath methods, they do not touch the filesystem. But, you can force them to access the filesystem if you give either function the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. >>> from wcmatch import pathlib >>> pathlib . PurePath ( 'docs/src' ) PosixPath('docs/src') Path classes implement the glob and globmatch methods: >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> p . match ( 'src' ) True >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True >>> list ( p . glob ( '**/*.txt' , flags = pathlib . GLOBSTAR )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] >>> list ( p . rglob ( '*.txt' )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')]","title":"pathlib.Path"},{"location":"pathlib/#pathlibwindowspath","text":"WindowsPath is Wildcard Match's version of Python's WindowsPath . The WindowsPath class is useful if you'd like to have the ease that pathlib offers when working with a path and be able to manipulate or gain access to to information about that file. You cannot instantiate this class on a Posix system. This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from Path . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . Path ( 'c:/some/path' ) WindowsPath('c:/some/path')","title":"pathlib.WindowsPath"},{"location":"pathlib/#pathlibposixpath","text":"PosixPath is Wildcard Match's version of Python's PosixPath . This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from pathlib.Path . PosixPath is Wildcard Match's version of Python's PosixPath . The PosixPath class is useful if you'd like to have the ease that pathlib offers when working with a path and be able to manipulate or gain access to to information about that file. You cannot instantiate this class on a Windows system. This class will utilize wcmatch.glob for all glob related actions. The class is subclassed from Path . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . Path ( '/usr/local/bin' ) PosixPath('/usr/local/bin')","title":"pathlib.PosixPath"},{"location":"pathlib/#methods","text":"","title":"Methods"},{"location":"pathlib/#purepathmatch","text":"def match ( self , patterns , * , flags = 0 ): match takes a pattern (or list of patterns), and flags. It will return a boolean indicating whether the objects file path was matched by the pattern(s). match mimics Python's pathlib version of match in that it uses a recursive logic. What this means is when you are matching a path in the form some/path/name , the patterns name , path/name and some/path/name will all match. Essentially, the pattern, if not an absolute pattern, behaves as if a GLOBSTAR pattern of **/ was added at the beginning of the pattern. match does not access the filesystem, but you can force the path to access the filesystem if you give it the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. Since Path is derived from PurePath , this method is also available in Path objects. >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . match ( 'src' ) True","title":"PurePath.match"},{"location":"pathlib/#purepathglobmatch","text":"def globmatch ( self , patterns , * , flags = 0 ): globmatch takes a pattern (or list of patterns), and flags. It will return a boolean indicating whether the objects file path was matched by the pattern(s). globmatch is similar to match except it does not use the same recursive logic that match does. In all other respects, it behaves the same. globmatch does not access the filesystem, but you can force the path to access the filesystem if you give it the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. Since Path is derived from PurePath , this method is also available in Path objects. >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True","title":"PurePath.globmatch"},{"location":"pathlib/#pathrglob","text":"def rglob ( self , patterns , * , flags = 0 ): rglob takes a pattern (or list of patterns) and will crawl the file system returning matching files. If a file/folder matches any regular patterns, it is considered a match. If a file matches any exclusion pattern (when enabling the NEGATE flag), then it will be not be returned. rglob mimics Python's pathlib version of rglob in that it uses a recursive logic. What this means is when you are matching a path in the form some/path/name , the patterns name , path/name and some/path/name will all match. Essentially, the pattern behaves as if a GLOBSTAR pattern of **/ was added at the beginning of the pattern. All paths returned are relative to the pathlib object. For this reason, absolute patterns are not supported. >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> list ( p . rglob ( '*.txt' )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')]","title":"Path.rglob"},{"location":"pathlib/#pathglob","text":"def glob ( self , patterns , * , flags = 0 ): glob takes a pattern (or list of patterns) and will crawl the file system returning matching files. If a file/folder matches any regular patterns, it is considered a match. If a file matches any exclusion pattern (when enabling the NEGATE flag), then it will be not be returned. glob is similar to rglob except it does not use the same recursive logic that rglob does. In all other respects, it behaves the same. All paths returned are relative to the pathlib object. For this reason, absolute patterns are not supported. >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> list ( p . glob ( '**/*.txt' , flags = pathlib . GLOBSTAR )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')]","title":"Path.glob"},{"location":"pathlib/#flags","text":"","title":"Flags"},{"location":"pathlib/#pathlibcase","text":"CASE forces case sensitivity. CASE has higher priority than IGNORECASE . On Windows, drive letters ( C: ) and UNC host/share ( //host/share ) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied.","title":"pathlib.CASE, pathlib.C"},{"location":"pathlib/#pathlibignorecase","text":"IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE .","title":"pathlib.IGNORECASE, pathlib.I"},{"location":"pathlib/#pathlibrawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' .","title":"glob.RAWCHARS, glob.R"},{"location":"pathlib/#pathlibnegate","text":"NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would match any file but Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. If used with the extended glob feature, patterns like !(inverse|pattern) will be mistakenly parsed as an exclusion pattern instead of as an inverse extended glob group. See MINUSNEGATE for an alternative syntax that plays nice with extended glob.","title":"pathlib.NEGATE, pathlib.N"},{"location":"pathlib/#pathlibnegateall","text":"NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: ** and !*.md , where !*.md is applied to the results of ** , and ** is specifically treated as if GLOBSTAR was enabled. Dot files will not be returned unless DOTGLOB is enabled. Symlinks will also be ignored in the return unless FOLLOW is enabled.","title":"pathlib.NEGATEALL, pathlib.A"},{"location":"pathlib/#pathlibminusnegate","text":"When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) .","title":"pathlib.MINUSNEGATE, pathlib.M"},{"location":"pathlib/#pathlibglobstar","text":"GLOBSTAR enables the feature where ** matches zero or more directories.","title":"pathlib.GLOBSTAR, pathlib.G"},{"location":"pathlib/#pathlibfollow","text":"FOLLOW will cause GLOBSTAR patterns ( ** ) to match and traverse symlink directories.","title":"pathlib.FOLLOW, pathlib.FL"},{"location":"pathlib/#pathlibrealpath","text":"In the past, only glob and iglob operated on the filesystem, but with REALPATH , other functions will now operate on the filesystem as well: globmatch and match . Normally, functions such as globmatch would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system. REALPATH forces globmatch and match to treat the path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match: Path must exist. Directories that are symlinks will not be matched by GLOBSTAR patterns ( ** ) unless the FOLLOW flag is enabled. When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a directory. Paths must match in relation to the current working directory unless the pattern is constructed in a way to indicates an absolute path.","title":"pathlib.REALPATH, pathlib.P"},{"location":"pathlib/#pathlibdotglob","text":"By default, globbing and matching functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , or ? . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash.","title":"pathlib.DOTGLOB, pathlib.D"},{"location":"pathlib/#pathlibextglob","text":"EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash.","title":"pathlib.EXTGLOB, pathlib.E"},{"location":"pathlib/#pathlibbrace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns.","title":"pathlib.BRACE, pathlib.B"},{"location":"pathlib/#pathlibsplit","text":"SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the delimiters if needed: \\| . >>> from wcmatch import glob >>> glob . globmatch ( 'test.txt' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> glob . globmatch ( 'test.py' , r '*.txt|*.py' , flags = fnmatch . SPLIT ) True","title":"pathlib.SPLIT, pathlib.S"},{"location":"pathlib/#pathlibmatchbase","text":"MATCHBASE , when a pattern has no slashes in it, will cause all glob related functions to seek for any file anywhere in the tree with a matching basename, or in the case of match and globmatch , path whose basename matches. >>> from wcmatch import glob >>> glob . glob ( '*.txt' , flags = glob . MATCHBASE ) ['docs/src/dictionary/en-custom.txt', 'docs/src/markdown/_snippets/abbr.txt', 'docs/src/markdown/_snippets/links.txt', 'docs/src/markdown/_snippets/posix.txt', 'docs/src/markdown/_snippets/refs.txt', 'requirements/docs.txt', 'requirements/lint.txt', 'requirements/setup.txt', 'requirements/test.txt', 'requirements/tools.txt']","title":"pathlib.MATCHBASE, pathlib.X"},{"location":"pathlib/#pathlibnodir","text":"NODIR will cause all glob related functions to return only matched files. In the case of PurePath classes, this may not be possible as those classes do not access the file system, nor will they retain trailing slashes. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . NODIR ) ['appveyor.yml', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'setup.cfg', 'setup.py', 'spell.log', 'tox.ini'] >>> glob . glob ( '*' ) ['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'spell.log', 'tests', 'tools', 'tox.ini', 'wcmatch']","title":"pathlib.NODIR, pathlib.O"},{"location":"wcmatch/","text":"wcmatch.wcmatch \ue157 from wcmatch import wcmatch Overview \ue157 wcmatch.WcMatch was originally written to provide a simple user interface for searching specific files in Rummage . A class was needed to facilitate a user interface where a user could select a base path, define one or more file patterns they wanted to search for, and provide folders to exclude if needed. It needed to be aware of hidden files on different systems, not just ignoring files that start with . . It also needed to be extendable so we could further filter returned files by size, creation date, or whatever else was decided. While glob is a fantastic file and folder search tool, it just didn't make sense for such a user interface. wcmatch.WcMatch \ue157 WcMatch is an extendable file search class. It allows you to specify a base path, file patterns, and optional folder exclude patterns. You can specify whether you want to see hidden files and whether the search should be recursive. You can also derive from the class and tap into specific hooks to change what is returned or done when a file is matched, skipped, or when there is an error. There are also hooks where you can inject additional, custom filtering. Parameter Default Description directory The base directory to search. file_pattern '' One or more patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). The default is an empty string, but if an empty string is used, all files will be matched. exclude_pattern '' Zero or more folder exclude patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). flags 0 Flags to alter behavior of folder and file matching. See Flags for more info. Note Dots are not treated special in wcmatch . When the HIDDEN flag is not included, all hidden files (system and dot files) are excluded from the crawling processes, so there is no risk of * matching a dot file as it will not show up in the crawl. If the HIDDEN flag is included, * , ? , and [.] will then match dot files. Removed in 3.0 show_hidden and recursive were removed to provide a more consistent interface. Hidden files and recursion can be enabled via the HIDDEN and RECURSIVE flag respectively. Examples \ue157 Searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md'] Recursively searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/installation.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md', './docs/src/markdown/_snippets/abbr.md', './docs/src/markdown/_snippets/links.md', './docs/src/markdown/_snippets/refs.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Excluding directories: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Using file negation patterns: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt|!README*' , 'docs' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] You can also use negation patterns in directory exclude. Here we avoid all folders with * , but add an exception for requirements . It should be noted that you cannot add an exception for the child of an excluded folder. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '*|!requirements' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Negative patterns can be given by themselves. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '!requirements' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Enabling hidden files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.yml' ) . match () ['./appveyor.yml', './mkdocs.yml'] >>> wcmatch . WcMatch ( '.' , '*.yml' , flags = wcmatch . HIDDEN ) . match () ['./.codecov.yml', './.travis.yml', './appveyor.yml', './mkdocs.yml'] Methods \ue157 WcMatch.match \ue157 Perform match returning files that match the patterns. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md'] WcMatch.imatch \ue157 Perform match returning an iterator of files that match the patterns. >>> from wcmatch import wcmatch >>> list ( wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . imatch ()) ['./LICENSE.md', './README.md'] WcMatch.kill \ue157 If searching with imatch , this provides a way to gracefully kill the internal searching. Internally, you can call is_aborted to check if a request to abort has been made. So if work on a file is being done in an on_match , you can check if there has been a request to kill the process, and tie up loose ends gracefully. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md Once a \"kill\" has been issued, the class will remain in an aborted state. To clear the \"kill\" state, you must call reset . This allows a process to define a Wcmatch class and reuse it. If a process receives an early kill and sets it before the match is started, when the match is started, it will immediately abort. This helps with race conditions depending on how you are using WcMatch . WcMatch.reset \ue157 Resets the abort state after running kill . >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md >>> wcm . reset () >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md'] WcMatch.is_aborted \ue157 Checks if an abort has been issued. >>> from wcmatch import wcmatch >>> wcm = wcmatch.WcMatch('.', '*.md|*.txt') >>> for f in wcm.imatch(): ... wcm.kill() ... >>> wcm.is_aborted() True New 4.1.0 is_aborted was added in 4.1.0. WcMatch.get_skipped \ue157 Returns the number of skipped files. Files in skipped folders are not included in the count. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md'] >>> wcm . get_skipped () 10 Hooks \ue157 WcMatch.on_init \ue157 def on_init ( self , * args , ** kwargs ): \"\"\"Handle custom init.\"\"\" Any arguments or keyword arguments not processed by the main initializer are sent to on_init . This allows you to specify additional arguments when deriving from WcMatch . WcMatch.on_validate_directory \ue157 def on_validate_directory ( self , base , name ): \"\"\"Validate folder override.\"\"\" return True When validating a directory, if the directory passes validation, it will be sent to on_validate_directory which can be overridden to provide additional validation if required. WcMatch.on_validate_file \ue157 def on_validate_file ( self , base , name ): \"\"\"Validate file override.\"\"\" return True When validating a file, if the file passes validation, it will be sent to on_validate_file which can be overridden to provide additional validation if required. WcMatch.on_skip \ue157 def on_skip ( self , base , name ): \"\"\"On skip.\"\"\" return None When a file that must be skipped is encountered (a file that doesn't pass validation), it is sent to on_skip . Here you could abort the search, store away information, or even create a special skip record to return. It is advised to create a special type for skip returns so that you can identify them when they are returned via match or imatch . WcMatch.on_error \ue157 def on_error ( self , base , name ): \"\"\"On error.\"\"\" return None When accessing or processing a file throws an error, it is sent to on_error . Here you could abort the search, store away information, or even create a special error record to return. It is advised to create a special type for error returns so that you can identify them when they are returned via match or imatch . WcMatch.on_match \ue157 def on_match ( self , base , name ): \"\"\"On match.\"\"\" return os . path . join ( base , name ) On match returns the path of the matched file. You can override on_match and change what is returned. You could return just the base, you could parse the file and return the content, or return a special match record with additional file meta data. on_match must return something, and all results will be returned via match or imatch . WcMatch.on_reset \ue157 def on_reset ( self ): \"\"\"On reset.\"\"\" pass on_reset is a hook to provide a way to reset any custom logic in classes that have derived from WcMatch . on_reset is called on every new match call. New 4.0 on_reset was added in 4.0. Flags \ue157 wcmatch.RECURSIVE, wcmatch.RV \ue157 RECURSIVE forces a recursive search that will crawl all subdirectories. New 3.0.0 Added in 3.0 and must be used instead of the old recursive parameter which has also been removed as of 3.0. wcmatch.HIDDEN, wcmatch.HD \ue157 HIDDEN enables the crawling of hidden directories and will return hidden files if the wildcard pattern matches. This enables not just dot files, but system hidden files as well. New 3.0.0 Added in 3.0 and must be used instead of the old show_hidden parameter which has also been removed as of 3.0. wcmatch.SYMLINK, wcmatch.SL \ue157 SYMLINK enables the crawling of symlink directories. By default, symlink directories are ignored during the file crawl. New 3.0.0 Added in 3.0. Additionally, symlinks are now ignored by default moving forward if SYMLINK is not enabled. wcmatch.CASE, wcmatch.C \ue157 CASE forces case sensitivity. CASE has higher priority than IGNORECASE . New 4.3.0 CASE is new in 4.3.0. wcmatch.IGNORECASE, wcmatch.I \ue157 IGNORECASE forces case insensitive searches. CASE has higher priority than IGNORECASE . wcmatch.RAWCHARS, wcmatch.R \ue157 RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode (including r '\\N{CHAR NAME}' ). wcmatch.EXTMATCH, wcmatch.E \ue157 EXTMATCH enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. wcmatch.BRACE, wcmatch.B \ue157 BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns. wcmatch.MINUSNEGATE, wcmatch.M \ue157 MINUSNEGATE requires negation patterns to use - instead of ! . wcmatch.DIRPATHNAME, wcmatch.DP \ue157 DIRPATHNAME will enable path name searching for excluded folder patterns, but it will not apply to file patterns. This is mainly provided for cases where you may have multiple folders with the same name, but you want to target a specific folder to exclude. The path name compared will be the entire path relative to the base path. So if the provided base folder was . , and the folder under evaluation is ./some/folder , some/folder will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs/src/markdown' , recursive = True , flags = wcmatch . DIRPATHNAME ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] wcmatch.FILEPATHNAME, wcmatch.FP \ue157 FILEPATHNAME will enable path name searching for the file patterns, but it will not apply to directory exclude patterns. The path name compared will be the entire path relative to the base path. So if the provided base folder was . , and the file under evaluation is ./some/file.txt , some/file.txt will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '**/*.md|!**/_snippets/*' , recursive = True , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] wcmatch.PATHNAME, wcmatch.P \ue157 PATHNAME enables both DIRPATHNAME and FILEPATHNAME . It is provided for convenience. wcmatch.MATCHBASE, wcmatch.X \ue157 When FILEPATHNAME or DIRPATHNAME is enabled, MATCHBASE will ensure that that the respective file or directory pattern, when there are no slashes in the pattern, seeks for any file anywhere in the tree with a matching basename. This is essentially the behavior when FILEPATHNAME and DIRPATHNAME is disabled, but with MATCHBASE , you can toggle the behavior by including slashes in your pattern. When we include no slashes: >>> wcmatch . WcMatch ( '.' , '*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] If we include slashes in the pattern, the path, not the basename, must match the pattern: >>> wcmatch . WcMatch ( '.' , 'docs/**/*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] If we have a leading slash, the pattern will not perform a match on the basename, but will instead be a normal path pattern that is anchored to the current base path, in this case . . >>> wcmatch . WcMatch ( '.' , '/*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md'] wcmatch.GLOBSTAR, wcmatch.G \ue157 When the PATHNAME flag is provided, you can also enable GLOBSTAR to enable the recursive directory pattern matches with ** . >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '**/markdown' , recursive = True , flags = wcmatch . DIRPATHNAME | wcmatch . GLOBSTAR ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']","title":"Wcmatch"},{"location":"wcmatch/#wcmatchwcmatch","text":"from wcmatch import wcmatch","title":"wcmatch.wcmatch"},{"location":"wcmatch/#overview","text":"wcmatch.WcMatch was originally written to provide a simple user interface for searching specific files in Rummage . A class was needed to facilitate a user interface where a user could select a base path, define one or more file patterns they wanted to search for, and provide folders to exclude if needed. It needed to be aware of hidden files on different systems, not just ignoring files that start with . . It also needed to be extendable so we could further filter returned files by size, creation date, or whatever else was decided. While glob is a fantastic file and folder search tool, it just didn't make sense for such a user interface.","title":"Overview"},{"location":"wcmatch/#wcmatchwcmatch_1","text":"WcMatch is an extendable file search class. It allows you to specify a base path, file patterns, and optional folder exclude patterns. You can specify whether you want to see hidden files and whether the search should be recursive. You can also derive from the class and tap into specific hooks to change what is returned or done when a file is matched, skipped, or when there is an error. There are also hooks where you can inject additional, custom filtering. Parameter Default Description directory The base directory to search. file_pattern '' One or more patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). The default is an empty string, but if an empty string is used, all files will be matched. exclude_pattern '' Zero or more folder exclude patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). flags 0 Flags to alter behavior of folder and file matching. See Flags for more info. Note Dots are not treated special in wcmatch . When the HIDDEN flag is not included, all hidden files (system and dot files) are excluded from the crawling processes, so there is no risk of * matching a dot file as it will not show up in the crawl. If the HIDDEN flag is included, * , ? , and [.] will then match dot files. Removed in 3.0 show_hidden and recursive were removed to provide a more consistent interface. Hidden files and recursion can be enabled via the HIDDEN and RECURSIVE flag respectively.","title":"wcmatch.WcMatch"},{"location":"wcmatch/#examples","text":"Searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md'] Recursively searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/installation.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md', './docs/src/markdown/_snippets/abbr.md', './docs/src/markdown/_snippets/links.md', './docs/src/markdown/_snippets/refs.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Excluding directories: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Using file negation patterns: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt|!README*' , 'docs' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] You can also use negation patterns in directory exclude. Here we avoid all folders with * , but add an exception for requirements . It should be noted that you cannot add an exception for the child of an excluded folder. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '*|!requirements' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Negative patterns can be given by themselves. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '!requirements' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Enabling hidden files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.yml' ) . match () ['./appveyor.yml', './mkdocs.yml'] >>> wcmatch . WcMatch ( '.' , '*.yml' , flags = wcmatch . HIDDEN ) . match () ['./.codecov.yml', './.travis.yml', './appveyor.yml', './mkdocs.yml']","title":"Examples"},{"location":"wcmatch/#methods","text":"","title":"Methods"},{"location":"wcmatch/#wcmatchmatch","text":"Perform match returning files that match the patterns. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md']","title":"WcMatch.match"},{"location":"wcmatch/#wcmatchimatch","text":"Perform match returning an iterator of files that match the patterns. >>> from wcmatch import wcmatch >>> list ( wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . imatch ()) ['./LICENSE.md', './README.md']","title":"WcMatch.imatch"},{"location":"wcmatch/#wcmatchkill","text":"If searching with imatch , this provides a way to gracefully kill the internal searching. Internally, you can call is_aborted to check if a request to abort has been made. So if work on a file is being done in an on_match , you can check if there has been a request to kill the process, and tie up loose ends gracefully. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md Once a \"kill\" has been issued, the class will remain in an aborted state. To clear the \"kill\" state, you must call reset . This allows a process to define a Wcmatch class and reuse it. If a process receives an early kill and sets it before the match is started, when the match is started, it will immediately abort. This helps with race conditions depending on how you are using WcMatch .","title":"WcMatch.kill"},{"location":"wcmatch/#wcmatchreset","text":"Resets the abort state after running kill . >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md >>> wcm . reset () >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md']","title":"WcMatch.reset"},{"location":"wcmatch/#wcmatchis_aborted","text":"Checks if an abort has been issued. >>> from wcmatch import wcmatch >>> wcm = wcmatch.WcMatch('.', '*.md|*.txt') >>> for f in wcm.imatch(): ... wcm.kill() ... >>> wcm.is_aborted() True New 4.1.0 is_aborted was added in 4.1.0.","title":"WcMatch.is_aborted"},{"location":"wcmatch/#wcmatchget_skipped","text":"Returns the number of skipped files. Files in skipped folders are not included in the count. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md'] >>> wcm . get_skipped () 10","title":"WcMatch.get_skipped"},{"location":"wcmatch/#hooks","text":"","title":"Hooks"},{"location":"wcmatch/#wcmatchon_init","text":"def on_init ( self , * args , ** kwargs ): \"\"\"Handle custom init.\"\"\" Any arguments or keyword arguments not processed by the main initializer are sent to on_init . This allows you to specify additional arguments when deriving from WcMatch .","title":"WcMatch.on_init"},{"location":"wcmatch/#wcmatchon_validate_directory","text":"def on_validate_directory ( self , base , name ): \"\"\"Validate folder override.\"\"\" return True When validating a directory, if the directory passes validation, it will be sent to on_validate_directory which can be overridden to provide additional validation if required.","title":"WcMatch.on_validate_directory"},{"location":"wcmatch/#wcmatchon_validate_file","text":"def on_validate_file ( self , base , name ): \"\"\"Validate file override.\"\"\" return True When validating a file, if the file passes validation, it will be sent to on_validate_file which can be overridden to provide additional validation if required.","title":"WcMatch.on_validate_file"},{"location":"wcmatch/#wcmatchon_skip","text":"def on_skip ( self , base , name ): \"\"\"On skip.\"\"\" return None When a file that must be skipped is encountered (a file that doesn't pass validation), it is sent to on_skip . Here you could abort the search, store away information, or even create a special skip record to return. It is advised to create a special type for skip returns so that you can identify them when they are returned via match or imatch .","title":"WcMatch.on_skip"},{"location":"wcmatch/#wcmatchon_error","text":"def on_error ( self , base , name ): \"\"\"On error.\"\"\" return None When accessing or processing a file throws an error, it is sent to on_error . Here you could abort the search, store away information, or even create a special error record to return. It is advised to create a special type for error returns so that you can identify them when they are returned via match or imatch .","title":"WcMatch.on_error"},{"location":"wcmatch/#wcmatchon_match","text":"def on_match ( self , base , name ): \"\"\"On match.\"\"\" return os . path . join ( base , name ) On match returns the path of the matched file. You can override on_match and change what is returned. You could return just the base, you could parse the file and return the content, or return a special match record with additional file meta data. on_match must return something, and all results will be returned via match or imatch .","title":"WcMatch.on_match"},{"location":"wcmatch/#wcmatchon_reset","text":"def on_reset ( self ): \"\"\"On reset.\"\"\" pass on_reset is a hook to provide a way to reset any custom logic in classes that have derived from WcMatch . on_reset is called on every new match call. New 4.0 on_reset was added in 4.0.","title":"WcMatch.on_reset"},{"location":"wcmatch/#flags","text":"","title":"Flags"},{"location":"wcmatch/#wcmatchrecursive","text":"RECURSIVE forces a recursive search that will crawl all subdirectories. New 3.0.0 Added in 3.0 and must be used instead of the old recursive parameter which has also been removed as of 3.0.","title":"wcmatch.RECURSIVE, wcmatch.RV"},{"location":"wcmatch/#wcmatchhidden","text":"HIDDEN enables the crawling of hidden directories and will return hidden files if the wildcard pattern matches. This enables not just dot files, but system hidden files as well. New 3.0.0 Added in 3.0 and must be used instead of the old show_hidden parameter which has also been removed as of 3.0.","title":"wcmatch.HIDDEN, wcmatch.HD"},{"location":"wcmatch/#wcmatchsymlink","text":"SYMLINK enables the crawling of symlink directories. By default, symlink directories are ignored during the file crawl. New 3.0.0 Added in 3.0. Additionally, symlinks are now ignored by default moving forward if SYMLINK is not enabled.","title":"wcmatch.SYMLINK, wcmatch.SL"},{"location":"wcmatch/#wcmatchcase","text":"CASE forces case sensitivity. CASE has higher priority than IGNORECASE . New 4.3.0 CASE is new in 4.3.0.","title":"wcmatch.CASE, wcmatch.C"},{"location":"wcmatch/#wcmatchignorecase","text":"IGNORECASE forces case insensitive searches. CASE has higher priority than IGNORECASE .","title":"wcmatch.IGNORECASE, wcmatch.I"},{"location":"wcmatch/#wcmatchrawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode (including r '\\N{CHAR NAME}' ).","title":"wcmatch.RAWCHARS, wcmatch.R"},{"location":"wcmatch/#wcmatchextmatch","text":"EXTMATCH enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc.","title":"wcmatch.EXTMATCH, wcmatch.E"},{"location":"wcmatch/#wcmatchbrace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns.","title":"wcmatch.BRACE, wcmatch.B"},{"location":"wcmatch/#wcmatchminusnegate","text":"MINUSNEGATE requires negation patterns to use - instead of ! .","title":"wcmatch.MINUSNEGATE, wcmatch.M"},{"location":"wcmatch/#wcmatchdirpathname","text":"DIRPATHNAME will enable path name searching for excluded folder patterns, but it will not apply to file patterns. This is mainly provided for cases where you may have multiple folders with the same name, but you want to target a specific folder to exclude. The path name compared will be the entire path relative to the base path. So if the provided base folder was . , and the folder under evaluation is ./some/folder , some/folder will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs/src/markdown' , recursive = True , flags = wcmatch . DIRPATHNAME ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']","title":"wcmatch.DIRPATHNAME, wcmatch.DP"},{"location":"wcmatch/#wcmatchfilepathname","text":"FILEPATHNAME will enable path name searching for the file patterns, but it will not apply to directory exclude patterns. The path name compared will be the entire path relative to the base path. So if the provided base folder was . , and the file under evaluation is ./some/file.txt , some/file.txt will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '**/*.md|!**/_snippets/*' , recursive = True , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md']","title":"wcmatch.FILEPATHNAME, wcmatch.FP"},{"location":"wcmatch/#wcmatchpathname","text":"PATHNAME enables both DIRPATHNAME and FILEPATHNAME . It is provided for convenience.","title":"wcmatch.PATHNAME, wcmatch.P"},{"location":"wcmatch/#wcmatchmatchbase","text":"When FILEPATHNAME or DIRPATHNAME is enabled, MATCHBASE will ensure that that the respective file or directory pattern, when there are no slashes in the pattern, seeks for any file anywhere in the tree with a matching basename. This is essentially the behavior when FILEPATHNAME and DIRPATHNAME is disabled, but with MATCHBASE , you can toggle the behavior by including slashes in your pattern. When we include no slashes: >>> wcmatch . WcMatch ( '.' , '*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] If we include slashes in the pattern, the path, not the basename, must match the pattern: >>> wcmatch . WcMatch ( '.' , 'docs/**/*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] If we have a leading slash, the pattern will not perform a match on the basename, but will instead be a normal path pattern that is anchored to the current base path, in this case . . >>> wcmatch . WcMatch ( '.' , '/*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md']","title":"wcmatch.MATCHBASE, wcmatch.X"},{"location":"wcmatch/#wcmatchglobstar","text":"When the PATHNAME flag is provided, you can also enable GLOBSTAR to enable the recursive directory pattern matches with ** . >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '**/markdown' , recursive = True , flags = wcmatch . DIRPATHNAME | wcmatch . GLOBSTAR ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']","title":"wcmatch.GLOBSTAR, wcmatch.G"}]}